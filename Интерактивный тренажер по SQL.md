

`Интерактивный тренажер по SQL`

Конспект материалов

# Основы реляционной модели и SQL

## Отношение (таблица)

Структура запроса:

```sql
SELECT 'столбцы или * для выбора всех столбцов; обязательно'

FROM 'таблица; обязательно'

WHERE 'условие/фильтрация, например, city = 'Moscow'; необязательно'

GROUP BY 'столбец, по которому хотим сгруппировать данные; необязательно'

HAVING 'условие/фильтрация на уровне сгруппированных данных; необязательно'

ORDER BY 'столбец, по которому хотим отсортировать вывод; необязательно'
```



### Основные понятия реляционных баз данных

![img](https://ucarecdn.com/5c077c69-ade0-401a-a9f0-d7efdd6c0ceb/)

- ***отношение*** – это структура данных целиком, набор записей (в обычном понимании – таблица) , в примере –это `**Сотрудник**`;
- ***кортеж*** – это каждая строка , содержащая данные (более распространенный термин – запись ), например, <00*1, Борин С.А, 234-01-23, программист*>, все кортежи в отношении должны быть различны;
- ***мощность*** – число кортежей в таблице (проще говоря, число записей), в данном случае 3, мощность отношения может быть любой (от 0 до бесконечности), порядок следования кортежей - неважен;
- ***атрибут*** – это столбец в таблице (более распространенный термин – поле ), в примере – `**Табельный номер, Фамилия И.О., Телефон, Должность**`) 
- ***размерность*** – это число атрибутов в таблице, в данном случае – 4;
- размерность отношения должна быть больше 0, порядок следования атрибутов существенен;
-  ***домен атрибута*** – это допустимые значения (неповторяющиеся), которые можно занести в поле , например для атрибута `**Должность**` домен – {инженер, программист}.

### Основные типы данных SQL:

| **Тип данных**      | **Описание**                                                 | **Пример**            |
| ------------------- | ------------------------------------------------------------ | --------------------- |
| `INT`  `INTEGER`    | Целое число, могут принимать значения от -2 147 483 648 до 2 147 483 647 | -567 1205             |
| `DECIMAL` `NUMERIC` | Вещественное число, в скобках указывается максимальная длина числа (включает символы слева и справа от десятичной запятой) и количество знаков после запятой. Можно использовать оба этих типа, они эквивалентны, принимают значения в диапазоне -1038+1 до 1038-1. `DECIMAL(4,1) NUMERIC(6,3)` | 34.6 -3.294           |
| `DATE`              | Дата в формате ГГГГ-ММ-ДД  *26 июля 2020 года 3 января 2021 года* | 2020-07-26 2021-01-03 |
| `VARCHAR`           | Строка длиной не более 255 символов, в скобках указывается максимальная длина строки, которая может храниться в поле `VARCHAR(10)(рассматриваются однобайтовые кодировки,для которых число в скобках соответствует максимальномуколичеству символов в строке)` | пример описание       |

### Создание таблицы

Для создания таблицы используется SQL-запрос. В нем указывается какая таблица создается, из каких атрибутов(полей) она состоит и какой тип данных имеет каждое поле, при необходимости указывается описание полей (ключевое поле и т.д.). Его структура :

- ключевые слова : `CREATE TABLE`
- имя создаваемой таблицы;
- открывающая круглая скобка «(»;
- название поля и его описание, которое включает тип поля и другие необязательные характеристики;
- запятая;
- название поля и его описание;
- ...
- закрывающая скобка «)».

**Пример.** Создадим таблицу `**genre**` следующей структуры:

| **Поле**   | **Тип, описание**                |
| ---------- | -------------------------------- |
| genre_id   | `INT PRIMARY KEY AUTO_INCREMENT` |
| name_genre | `VARCHAR(30)`                    |

```sql
CREATE TABLE genre(
    genre_id INT PRIMARY KEY AUTO_INCREMENT, 
    name_genre VARCHAR(30)
);
```



Сформулируйте SQL запрос для создания таблицы `**book**`, занесите его в окно кода (расположено ниже) и отправьте на проверку (кнопка **Отправить**). Структура таблицы `**book**`:

| **Поле**  | **Тип, описание**                |
| --------- | -------------------------------- |
| `book_id` | `INT PRIMARY KEY AUTO_INCREMENT` |
| `title`   | `VARCHAR(50)`                    |
| `author`  | `VARCHAR(30)`                    |
| `price`   | `DECIMAL(8, 2)`                  |
| `amount`  | `INT`                            |

```sql
create table book(
    book_id int primary key auto_increment,
    title varchar(50),
    author varchar(30),
    price decimal(8, 2),
    amount int
)
```

### Вставка записи в таблицу

Для занесения новой записи в таблицу используется SQL запрос, в котором указывается в какую таблицу, в какие поля заносить новые значения. Структура запроса:

- ключевые слова `INSERT INTO` (ключевое слово `INTO `можно пропустить);
- имя таблицы, в которую добавляется запись;
- открывающая круглая скобка «(»;
-  список полей через запятую, в которые следует занести новые данные;
- закрывающая скобка «)»;
- ключевое слово `VALUES`;
- открывающая круглая скобка «(»;
- список значений через запятую, которые заносятся в соответствующие поля, при этом текстовые значения заключаются в кавычки, числовые значения записываются без кавычек, в качестве разделителя целой и дробной части используется точка;
- закрывающая скобка «)».

**Пример.** В `**таблицу**`, состоящую из двух столбцов добавим новую строку, при этом в `**поле1**` заносится` **значение1**`, в `**поле2**` - `**значение2**`.

```sql
INSERT INTO таблица(поле1, поле2) 
VALUES (значение1, значение2);
```

Занесите новую строку в таблицу**` book`** (текстовые значения (тип `**VARCHAR**`) заключать либо в двойные, либо в одинарные кавычки):

| **book_id**                    | **title**          | **author**    | **price**    | **amount** |
| ------------------------------ | ------------------ | ------------- | ------------ | ---------- |
| INT PRIMARY KEY AUTO_INCREMENT | VARCHAR(50)        | VARCHAR(30)   | DECIMAL(8,2) | INT        |
| 1                              | Мастер и Маргарита | Булгаков М.А. | 670.99       | 3          |

```sql
insert into book (title, author, price, amount)
values ('Мастер и Маргарита', 'Булгаков М.А.', 670.99, 3);
select * from book;
```

Занесите три последние записи в таблицу`**book**`, первая запись уже добавлена на предыдущем шаге:

| **book_id**                        | **title**          | **author**       | **price**        | **amount** |
| ---------------------------------- | ------------------ | ---------------- | ---------------- | ---------- |
| **INT PRIMARY KEY AUTO_INCREMENT** | **VARCHAR(50)**    | **VARCHAR(30)**  | **DECIMAL(8,2)** | **INT**    |
| 1                                  | Мастер и Маргарита | Булгаков М.А.    | 670.99           | 3          |
| 2                                  | Белая гвардия      | Булгаков М.А.    | 540.50           | 5          |
| 3                                  | Идиот              | Достоевский Ф.М. | 460.00           | 10         |
| 4                                  | Братья Карамазовы  | Достоевский Ф.М. | 799.01           | 2          |

```sql
insert into book(title, author, price, amount)
values ('Белая гвардия', 'Булгаков М.А.', 540.50, 5);

insert into book(title, author, price, amount)
values ('Идиот', 'Достоевский Ф.М.', 460.00, 10);

insert into book(title, author, price, amount)
values ('Братья Карамазовы', 'Достоевский Ф.М.', 799.01, 2);

select * from book;
```

## Выборка данных

Для того чтобы отобрать данные из определенных столбцов таблицы используется SQL запрос следующей структуры: 

- ключевое слово `**SELECT**` ; 
- список столбцов таблицы через запятую или ***** если хоти выбрать все столбцы; 
- ключевое слово` **FROM**` ; 
- имя таблицы.

```sql
select author, title, price from book;
```

Для того чтобы отобрать данные из определенных столбцов таблицы и одновременно задать столбцам новые имена используется SQL запрос следующей структуры: 

- ключевое слово `**SELECT** `; 
- имя столбца;
- ключевое слово `**AS**` ; 
- новое название столбца (можно русскими буквами), но это должно быть одно слово, если название состоит из двух слов – соединяйте их подчеркиванием, например, `**Количество_книг** `; 
- запятая; 
- имя столбца; 
- .... 
- ключевое слово` **FROM**` ; 
- имя таблицы.

```sql
select title as 'Название', author as 'Автор' from book;
```

Выборка данных с созданием вычисляемого столбца:

С помощью SQL запросов можно осуществлять вычисления по каждой строке таблицы с помощью вычисляемого столбца. Для него в списке полей после оператора `**SELECT**` указывается выражение и задается имя.

Выражение может включать имена столбцов, константы, знаки операций, встроенные функции.

Результатом является таблица, в которую включены все данные из указанных после `**SELECT**` столбцов, а также новый столбец, в каждой строке которого вычисляется заданное выражение.

**Пример**

Вывести всю информацию о книгах, а также для каждой позиции посчитать ее стоимость (произведение цены на количество). Вычисляемому столбцу дать имя `**total**` .

*Запрос:*

```sql
SELECT title, author, price, amount, 
     price * amount AS total 
FROM book;
```

*Результат:*

```sql
+-----------------------+------------------+--------+--------+---------+ 
| title                 | author           | price  | amount | total   | 
+-----------------------+------------------+--------+--------+---------+ 
| Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      | 2012.97 | 
| Белая гвардия         | Булгаков М.А.    | 540.50 | 5      | 2702.50 | 
| Идиот                 | Достоевский Ф.М. | 460.00 | 10     | 4600.00 | 
| Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      | 1598.02 | 
| Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     | 9750.00 |
+-----------------------+------------------+--------+--------+---------+ 
```

### Выборка данных, вычисляемые столбцы, математические функции

В SQL реализовано множество [математических функций](https://docs.microsoft.com/ru-ru/sql/t-sql/functions/mathematical-functions-transact-sql?view=sql-server-ver15) для работы с числовыми данными. В таблице приведены некоторые из них.

| **Функция**   | **Описание**                                                 | **Пример**                           |
| ------------- | ------------------------------------------------------------ | ------------------------------------ |
| `CEILING(x)`  | возвращает наименьшее целое число, большее или равное **x** (округляет до целого числа в большую сторону) | `CEILING(4.2)=5CEILING(-5.8)=-5`     |
| `ROUND(x, k)` | округляет значение **x** до **k** знаков после запятой, если **k** не указано – **x** округляется до целого | `ROUND(4.361)=4ROUND(5.86592,1)=5.9` |
| `FLOOR(x)`    | возвращает наибольшее целое число, меньшее или равное **x** (округляет до целого числа в меньшую сторону) | `FLOOR(4.2)=4FLOOR(-5.8)=-6`         |
| `POWER(x, y)` | возведение **x** в степень **y**                             | `POWER(3,4)=81.0`                    |
| `SQRT(x)`     | квадратный корень из **x**                                   | `SQRT(4)=2.0SQRT(2)=1.41...`         |
| `DEGREES(x)`  | конвертирует значение **x** из радиан в градусы              | `DEGREES(3) = 171.8...`              |
| `RADIANS(x)`  | конвертирует значение **x** из градусов в радианы            | `RADIANS(180)=3.14...`               |
| `ABS(x)`      | модуль числа **x**                                           | `ABS(-1) = 1ABS(1) = 1`              |
| `PI()`        | pi = 3.1415926...                                            |                                      |

### Выборка данных, вычисляемые столбцы, логические функции

В SQL реализована возможность заносить в поле значение в зависимости от условия. Для этого используется функция `IF`:

```sql
IF(логическое_выражение, выражение_1, выражение_2)
```

Функция вычисляет `логическое_выражение,` если оно истина – в поле заносится значение `выражения_1`, в противном случае – значение `выражения_2. `Все три параметра `IF() `являются обязательными.

Допускается использование вложенных функций, вместо `выражения_1` или `выражения_2` может стоять новая функция `**IF**`.

**Пример** 

Для каждой книги из таблицы `**book**` установим скидку следующим образом: если количество книг меньше 4, то скидка будет составлять 50% от цены, в противном случае 30%.

*Запрос:*

```sql
SELECT title, amount, price, 
    IF(amount<4, price*0.5, price*0.7) AS sale
FROM book;
```

*Результат:*

```sql
+-----------------------+--------+--------+---------+
| title                 | amount | price  | sale    |
+-----------------------+--------+--------+---------+
| Мастер и Маргарита    | 3      | 670.99 | 335.495 |
| Белая гвардия         | 5      | 540.50 | 378.350 |
| Идиот                 | 10     | 460.00 | 322.000 |
| Братья Карамазовы     | 2      | 799.01 | 399.505 |
| Стихотворения и поэмы | 15     | 650.00 | 455.000 |
+-----------------------+--------+--------+---------+
```

Цена по скидке должна отображаться с двумя знаками после запятой, добавим в запрос округление:

```sql
SELECT title, amount, price, 
    ROUND(IF(amount<4, price*0.5, price*0.7),2) AS sale
FROM book;
```

*Результат:*

```sql
+-----------------------+--------+--------+--------+
| title                 | amount | price  | sale   |
+-----------------------+--------+--------+--------+
| Мастер и Маргарита    | 3      | 670.99 | 335.50 |
| Белая гвардия         | 5      | 540.50 | 378.35 |
| Идиот                 | 10     | 460.00 | 322.00 |
| Братья Карамазовы     | 2      | 799.01 | 399.51 |
| Стихотворения и поэмы | 15     | 650.00 | 455.00 |
+-----------------------+--------+--------+--------+
```

### Выборка данных по условию

С помощью запросов можно включать в итоговую выборку не все строки исходной таблицы, а только те, которые отвечают некоторому условию. Для этого после указания таблицы, откуда выбираются данные, задается ключевое слово `WHERE` и логическое выражение, от результата которого зависит будет ли включена строка в выборку или нет. Если условие – истина, то строка(запись)  включается в выборку, если ложь – нет.

Логическое выражение может включать **операторы сравнения** (равно «**=**», не равно «**<>**», больше «**>**», меньше «**<**», больше или равно«**>=**», меньше или равно «**<=**») и выражения, допустимые в SQL.

**Пример**

Вывести название и цену тех книг, цены которых меньше 600 рублей.

*Запрос:*

```sql
SELECT title, price 
FROM book
WHERE price < 600;
```

*Результат:*

```sql
+---------------+--------+
| title         | price  |
+---------------+--------+
| Белая гвардия | 540.50 |
| Идиот         | 460.00 |
+---------------+--------+
```

### **Выборка данных, логические операции**

 Логическое выражение после ключевого слова `WHERE` кроме операторов сравнения и выражений может включать  **логические операции** (И «**and**», ИЛИ «**or**», НЕ «**not**») и круглые скобки, изменяющие приоритеты выполнения операций.

Приоритеты операций:

1. круглые скобки
2. умножение  (*),  деление (/)
3. сложение  (+), вычитание (-)
4. операторы сравнения (=, >, <, >=, <=, <>)
5. NOT
6. AND
7. OR

**Пример**

Вывести название, автора и цену тех книг, которые написал Булгаков, ценой больше 600 рублей

*Запрос:*

```sql
SELECT title, author, price 
FROM book
WHERE price > 600 AND author = 'Булгаков М.А.';
```

*Результат:*

```sql
+--------------------+---------------+--------+
| title              | author        | price  |
+--------------------+---------------+--------+
| Мастер и Маргарита | Булгаков М.А. | 670.99 |
+--------------------+---------------+--------+
```

### Выборка данных, операторы BETWEEN, IN

 Логическое выражение после ключевого слова `WHERE` может включать операторы  **`BETWEEN`** и **`IN`**. Приоритет у этих операторов такой же как у операторов сравнения, то есть они выполняются раньше, чем `**NOT**`, `**AND**,` `**OR**`.

Оператор `BETWEEN` позволяет отобрать данные, относящиеся к некоторому интервалу, включая его границы.

**Пример**

Выбрать названия и количества тех книг, количество которых от 5 до 14 включительно.

*Запрос:*

```sql
SELECT title, amount 
FROM book
WHERE amount BETWEEN 5 AND 14;
```

*Результат:*

```sql
+---------------+--------+
| title         | amount |
+---------------+--------+
| Белая гвардия | 5      |
| Идиот         | 10     |
+---------------+--------+
```

Этот запрос можно реализовать по-другому, результат будет точно такой же.

```sql
SELECT title, amount 
FROM book
WHERE amount >= 5 AND amount <=14;
```

Оператор  `IN` позволяет выбрать данные, соответствующие значениям из списка.

**Пример**

Выбрать названия и цены книг, написанных Булгаковым или Достоевским.

*Запрос:*

```sql
SELECT title, price 
FROM book
WHERE author IN ('Булгаков М.А.', 'Достоевский Ф.М.');
```

*Результат:*

```sql
+--------------------+--------+
| title              | price  |
+--------------------+--------+
| Мастер и Маргарита | 670.99 |
| Белая гвардия      | 540.50 |
| Идиот              | 460.00 |
| Братья Карамазовы  | 799.01 |
+--------------------+--------+
```

Этот запрос можно реализовать по-другому, результат будет точно такой же.

```sql
SELECT title, price 
FROM book
WHERE author = 'Булгаков М.А.' OR author = 'Достоевский Ф.М.';
```

### Выборка данных с сортировкой

При выборке можно указывать столбец или несколько столбцов, по которым необходимо отсортировать отобранные строки. Для этого используются ключевые слова `ORDER BY`, после которых задаются имена столбцов. При этом строки сортируются по первому столбцу, если указан второй столбец, сортировка осуществляется только для тех строк, у которых значения первого столбца одинаковы. По умолчанию `ORDER BY` выполняет сортировку по возрастанию. Чтобы управлять направлением сортировки вручную, после имени столбца указывается ключевое слово `ASC` (по возрастанию) или `DESC` (по убыванию). 

Столбцы после ключевого слова `ORDER BY` можно задавать:

- названием столбца;
- номером столбца;
- именем столбца (указанным после `AS`).

**Пример**

Вывести название, автора и цены книг. Информацию  отсортировать по названиям книг в алфавитном порядке.

*Запрос:*

```sql
SELECT title, author, price
FROM book
ORDER BY title;
```

*Результат:*

```sql
+-----------------------+------------------+--------+
| title                 | author           | price  |
+-----------------------+------------------+--------+
| Белая гвардия         | Булгаков М.А.    | 540.50 |
| Братья Карамазовы     | Достоевский Ф.М. | 799.01 |
| Идиот                 | Достоевский Ф.М. | 460.00 |
| Мастер и Маргарита    | Булгаков М.А.    | 670.99 |
| Стихотворения и поэмы | Есенин С.А.      | 650.00 |
+-----------------------+------------------+--------+
```

Аналогичный результат получится при использовании запроса:

```sql
SELECT title, author, price
FROM book
ORDER BY 1;
```

### Выборка данных, оператор LIKE

Оператор `LIKE` используется для сравнения строк. В отличие от операторов отношения равно (**=**) и не равно (**<>**), `LIKE` позволяет сравнивать строки не на полное совпадение (не совпадение), а в соответствии с шаблоном. Шаблон может включать **обычные символы** и **символы-шаблоны**. При сравнении с шаблоном, его обычные символы должны в точности совпадать с символами, указанными в строке. Символы-шаблоны могут совпадать с произвольными элементами символьной строки.

| Символ-шаблон         | Описание                                         | Пример                                                       |
| :-------------------- | :----------------------------------------------- | :----------------------------------------------------------- |
| **%**                 | Любая строка, содержащая ноль или более символов | `SELECT * FROM book WHERE author LIKE '%М.%'` выполняет поиск и выдает все книги, инициалы авторов которых содержат «*М.*» |
| **_** (подчеркивание) | Любой одиночный символ                           | `SELECT * FROM book WHERE title LIKE 'Поэм_'` выполняет поиск и выдает все книги, названия которых либо «*Поэма*», либо «*Поэмы*» и пр. |

**Пример 1**

Вывести названия книг, начинающихся с буквы «*Б*».

*Запрос:*

```sql
SELECT title 
FROM book
WHERE title LIKE 'Б%';
/* эквивалентное условие 
title LIKE 'б%'
*/
```

*Результат:*

```sql
+-------------------+
| title             |
+-------------------+
| Белая гвардия     |
| Братья Карамазовы |
+-------------------+
```

## Запросы, групповые операции

### Выбор уникальных элементов столбца

Чтобы отобрать уникальные элементы некоторого столбца используется ключевое слово `DISTINCT`, которое размещается сразу после `SELECT`.

**Пример**

Выбрать различных авторов, книги которых хранятся в таблице` **book**`.

*Запрос:*

```sql
SELECT DISTINCT author
FROM book;
```

*Результат:*

```sql
+------------------+
| author           |
+------------------+
| Булгаков М.А.    |
| Достоевский Ф.М. |
| Есенин С.А.      |
+------------------+
```

Другой способ – использование оператора `GROUP BY`, который группирует данные при выборке, имеющие одинаковые значения в некотором столбце. Столбец, по которому осуществляется группировка, указывается после `GROUP BY` .

С помощью `GROUP BY` можно выбрать уникальные элементы столбца, по которому осуществляется группировка. Результат будет точно такой же как при использовании `DISTINCT`.

*Запрос:*

```sql
SELECT  author
FROM book
GROUP BY author;
```

### Выборка данных, групповые функции SUM и COUNT

При группировке над элементами столбца, входящими в группу можно выполнить различные действия, например, просуммировать их или найти количество элементов в группе.

Подробно рассмотрим, как осуществляется группировка данных по некоторому столбцу и вычисления над группой на следующем примере:

```
SELECT author, sum(amount), count(amount)
FROM book
GROUP BY author;
```

\1. В таблице `**book**` определяются строки, в которых в столбце `**author**` одинаковые значения:

![img](https://ucarecdn.com/2c9cc54f-b3b0-4388-8443-bcf590176622/)

Получили 3 различные группы:

- **группа I** объединяет две записи, у которых в столбце `**author**` значение Булгаков М.А.;
- **группа II** объединяет три записи, у которых в столбце `**author**` значение Достоевский Ф.М.;
- **группа III** объединяет одну запись, у которой в столбце `**author**` значение Есенин С.А.

\2. Вместо каждой группы в результирующий запрос включается одна запись. Запись как минимум включает значение столбца, по которому осуществляется группировка (в нашем случае это `**author**`):

![img](https://ucarecdn.com/8265a790-2164-44ee-882a-d2ef67fa75d4/)

\3. Дальше можно выполнить вычисления над элементами КАЖДОЙ группы в отдельности, например, посчитать общее количество экземпляров книг каждого автора. Для этого используется групповая функция `SUM()`, а в скобках указывается столбец, по которому нужно выполнить суммирование ( в нашем случае `**amount**`):

![img](https://ucarecdn.com/8ef972d9-842b-438c-a4c5-e13a0a17d9fb/)

\4. Также можно посчитать, сколько записей относится к группе. Для этого используется функция `COUNT()`, в скобках можно указать ЛЮБОЙ столбец из группы, если группа не содержит пустых значений (ниже приведен пример, в котором показано, как работает `**COUNT()**`, если в группе есть пустые значения):

![img](https://ucarecdn.com/708aa6d7-f879-41b4-8030-103e4b43754e/)

**Пример**

Посчитать, сколько экземпляров книг каждого автора хранится на складе.

*Запрос:*

```sql
SELECT author, SUM(amount)
FROM book
GROUP BY author;
```

*Результат:*

```sql
+------------------+-------------+
| author           | SUM(amount) |
+------------------+-------------+
| Булгаков М.А.    | 8           |
| Достоевский Ф.М. | 23          |
| Есенин С.А.      | 15          |
+------------------+-------------+
```

### Выборка данных, групповые функции MIN, MAX и AVG

К групповым функциям SQL относятся: `MIN()`, `MAX()` и `AVG()`, которые вычисляют минимальное, максимальное и среднее значение элементов столбца, относящихся к группе.

**Пример**

Вывести минимальную цену книги каждого автора

*Запрос:*

```sql
SELECT author, MIN(price) AS min_price
FROM book
GROUP BY author;
```

*Результат:*

```sql
+------------------+-----------+
| author           | min_price |
+------------------+-----------+
| Булгаков М.А.    | 540.50    |
| Достоевский Ф.М. | 460.00    |
| Есенин С.А.      | 650.00    |
+------------------+-----------+
```

### Выборка данных c вычислением, групповые функции

В качестве аргумента групповых функций  SQL может использоваться не только столбец, но и любое допустимое в SQL арифметическое выражение.

**Пример**

Вывести суммарную стоимость книг каждого автора.

*Запрос:*

```sql
SELECT author, SUM(price * amount) AS Стоимость
FROM book
GROUP BY author;
```

*Результат:*

```sql
+------------------+-----------+
| author           | Стоимость |
+------------------+-----------+
| Булгаков М.А.    | 4715.47   |
| Достоевский Ф.М. | 11802.03  |
| Есенин С.А.      | 9750.00   |
+------------------+-----------+
```

Групповые функции могут быть элементами выражений. Например, при вычислении средней стоимости книг каждого автора на предыдущем шаге получились значения с шестью знаками после запятой. А поскольку это деньги, значения нужно округлить до 2 знаков после запятой.

 **Пример**

Найти среднюю цену книг каждого автора.

*Запрос:*

```sql
SELECT author, ROUND(AVG(price),2) AS Средняя_цена
FROM book
GROUP BY author;
```

*Результат:*

```sql
+------------------+--------------+
| author           | Средняя_цена |
+------------------+--------------+
| Булгаков М.А.    | 605.75       |
| Достоевский Ф.М. | 579.84       |
| Есенин С.А.      | 650.00       |
+------------------+--------------+
```

### Вычисления по таблице целиком

Групповые функции позволяют вычислять итоговые значения по всей таблице. Например, можно посчитать общее количество книг на складе, вычислить суммарную стоимость и пр. Для этого после ключевого слова `SELECT` указывается групповая функция для выражения или имени столбца, а ключевые слова `GROUP BY` опускаются.

**Пример**

Посчитать количество экземпляров книг на складе.

*Запрос:*

```sql
SELECT SUM(amount) AS Количество
FROM book;
```

*Результат:*

```sql
+------------+
| Количество |
+------------+
| 46         |
+------------+ 
```

Результатом таких запросов является единственная строка с вычисленными по таблице значениями.

 **Пример**

Посчитать общее количество экземпляров книг на складе и их стоимость .

*Запрос:*

```sql
SELECT SUM(amount) AS Количество, 
    SUM(price * amount) AS Стоимость
FROM book;
```

*Результат:*

```sql
+------------+-----------+
| Количество | Стоимость |
+------------+-----------+
| 46         | 26267.50  |
+------------+-----------+
```

### Выборка данных по условию, групповые функции

В запросы с групповыми функциями можно включать условие отбора строк, которое в обычных запросах записывается после `WHERE`. В запросах с групповыми функциями вместо `WHERE` используется ключевое слово `HAVING` , которое размещается после оператора `GROUP BY`.

**Пример**

Найти минимальную и максимальную цену книг всех авторов, общая стоимость книг которых больше 5000.

*Запрос:*

```sql
SELECT author,
    MIN(price) AS Минимальная_цена, 
    MAX(price) AS Максимальная_цена
FROM book
GROUP BY author
HAVING SUM(price * amount) > 5000; 
```

*Результат:*

```sql
+------------------+------------------+-------------------+
| author           | Минимальная_цена | Максимальная_цена |
+------------------+------------------+-------------------+
| Достоевский Ф.М. | 460.00           | 799.01            |
| Есенин С.А.      | 650.00           | 650.00            |
+------------------+------------------+-------------------+
```

Также в запросах с группировкой можно сортировать данные.

 **Пример**

Найти минимальную и максимальную цену книг всех авторов, общая стоимость книг которых больше 5000. Результат вывести по убыванию минимальной цены.

*Запрос:*

```sql
SELECT author,
    MIN(price) AS Минимальная_цена, 
    MAX(price) AS Максимальная_цена
FROM book
GROUP BY author
HAVING SUM(price * amount) > 5000 
ORDER BY Минимальная_цена DESC;
```

*Результат:*

```sql
+------------------+------------------+-------------------+
| author           | Минимальная_цена | Максимальная_цена |
+------------------+------------------+-------------------+
| Есенин С.А.      | 650.00           | 650.00            |
| Достоевский Ф.М. | 460.00           | 799.01            |
+------------------+------------------+-------------------+
```

### Выборка данных по условию, групповые функции, WHERE и HAVING

*Для этого урока теоретическая часть подготовлена [Alexandra Klinnikova](https://stepik.org/users/2290685), спасибо большое!*

`WHERE` и `HAVING` могут использоваться в одном запросе. При этом необходимо учитывать **порядок выполнения  SQL запроса на выборку на СЕРВЕРЕ**:

1. FROM
2. WHERE
3. GROUP BY
4. HAVING
5. SELECT
6. ORDER BY

Сначала определяется таблица, из которой выбираются данные (`FROM`), затем из этой таблицы отбираются записи в соответствии с условием `WHERE`, выбранные данные агрегируются (`GROUP BY`), из агрегированных записей выбираются те, которые удовлетворяют условию после `HAVING`. Потом формируются данные результирующей выборки, как это указано после `SELECT` ( вычисляются выражения, присваиваются имена и пр. ). Результирующая выборка сортируется, как указано после `ORDER BY`.

**Важно!** Порядок ВЫПОЛНЕНИЯ запросов - это не порядок ЗАПИСИ ключевых слов в запросе на выборку. Порядок записи (синтаксис запроса) остается таким же, как рассматривался ранее в курсе. Порядок ВЫПОЛНЕНИЯ нужен для того, чтобы понять, почему, например, в `**WHERE**` нельзя использовать имена выражений из `**SELECT**`. Просто `**SELECT**` выполняется компилятором позже, чем `**WHERE**`, поэтому ему неизвестно, какое там выражение написано.

**Пример**

Вывести максимальную и минимальную цену книг каждого автора, кроме Есенина, количество экземпляров книг которого больше 10. 

```sql
SELECT author,
    MIN(price) AS Минимальная_цена,
    MAX(price) AS Максимальная_цена
FROM book
WHERE author <> 'Есенин С.А.'
GROUP BY author
HAVING SUM(amount) > 10;
```

*Результат:*

```sql
+------------------+------------------+-------------------+
| author           | Минимальная_цена | Максимальная_цена |
+------------------+------------------+-------------------+
| Достоевский Ф.М. | 460.00           | 799.01            |
+------------------+------------------+-------------------+
```

Другим способом решения примера является запрос:

```sql
SELECT author,
    MIN(price) AS Минимальная_цена,
    MAX(price) AS Максимальная_цена
FROM book
GROUP BY author
HAVING SUM(amount) > 10 AND author <> 'Есенин С.А.';
```

Не смотря на то что результат будет одинаковым, так делать **не рекомендуется**. «Потому что как написано - запрос сначала выбирает всех авторов, потом выводит данные, рассчитывая минимальное и максимальное значение цены для каждого, и только после всего убирает Есенина. Можно убрать Есенина в данном случае раньше и не использовать ресурсы базы для расчета его минимального и максимального значения, как это сделано в первом варианте. На небольшой базе быстродействия не ощутить, но если выполнять такое на продуктивной, то второй вариант значительно проигрывает...»[[Alexandra Klinnikova](https://stepik.org/users/2290685)].

## Вложенные запросы

SQL позволяет создавать вложенные запросы. Вложенный запрос (подзапрос, внутренний запрос) – это запрос внутри другого запроса SQL.

Вложенный запрос используется для выборки данных, которые будут использоваться в условии отбора записей основного запроса. Его применяют для:

- сравнения выражения с результатом вложенного запроса;
- определения того, включено ли выражение в результаты вложенного запроса;
- проверки того, выбирает ли запрос определенные строки.

Вложенный запрос имеет следующие компоненты:

- ключевое слово `SELECT` после которого указываются имена столбцов или выражения (чаще всего список содержит один элемент) ;
- ключевое слово `FROM `и имя таблицы, из которой выбираются данные;
- необязательное предложение `WHERE`;
- необязательное предложение `GROUP BY:`
- необязательное предложение `HAVING`.

 Вложенные запросы могут включаться в WHERE или HAVING так (в квадратных скобках указаны необязательные элементы, через | – один из элементов):

- `WHERE | HAVING выражение *оператор_сравнения* (вложенный запрос)`;
- `WHERE | HAVING выражение, включающее вложенный запрос**;**`
- `WHERE | HAVING выражение [NOT] IN (вложенный запрос)`;
- `WHERE | HAVING выражение  *оператор_сравнения* ANY | ALL (вложенный запрос)`.

Также вложенные запросы могут вставляться в основной запрос после ключевого слова `SELECT`.

### Вложенный запрос, возвращающий одно значение

Вложенный запрос, возвращающий одно значение, может использоваться в условии отбора записей `WHERE` как обычное значение совместно с операциями =, <>, >=, <=, >, <.

**Пример**

Вывести информацию о самых дешевых книгах, хранящихся на складе.

Для реализации этого запроса нам необходимо получить минимальную цену из столбца `**price**` таблицы `**book**`, а затем вывести информацию о тех книгах, цена которых  равна минимальной. Первая часть  – поиск  минимума – реализуется вложенным запросом.

*Запрос:*

```sql
SELECT title, author, price, amount
FROM book
WHERE price = (
         SELECT MIN(price) 
         FROM book
      );
```

*Результат:*

```sql
+-------+------------------+--------+--------+
| title | author           | price  | amount |
+-------+------------------+--------+--------+
| Идиот | Достоевский Ф.М. | 460.00 | 10     |
+-------+------------------+--------+--------+
```

Вложенный запрос определяет минимальную цену книг во всей таблице (это 460.00), а затем в основном запросе для каждой записи проверяется, равна ли цена минимальному значению, если равна, информация о книге включается в результирующую таблицу запроса.

**Рекомендация.** При использовании вложенного запроса рекомендуется сначала проверить, правильно ли он работает (занести текст запроса в окно кода и нажать черную кнопку **Запустить**), если выдается верный результат – использовать код в качестве вложенного запроса.

### Использование вложенного запроса в выражении

Вложенный запрос, возвращающий одно значение, может использоваться в выражениях как обычный операнд, например, к нему можно что-то прибавить, вычесть и пр.

**Пример**

Вывести информацию о книгах, количество экземпляров которых отличается от среднего количества экземпляров книг на складе более чем на 3. То есть нужно вывести и те книги, количество экземпляров которых меньше среднего на 3, или больше среднего на 3.

*Запрос:*

```sql
SELECT title, author, amount 
FROM book
WHERE ABS(amount - (SELECT AVG(amount) FROM book)) >3;
```

*Результат:*

```sql
+-----------------------+------------------+--------+
| title                 | author           | amount |
+-----------------------+------------------+--------+
| Мастер и Маргарита    | Булгаков М.А.    | 3      |
| Братья Карамазовы     | Достоевский Ф.М. | 3      |
| Стихотворения и поэмы | Есенин С.А.      | 15     |
+-----------------------+------------------+--------+
```

### Вложенный запрос, оператор IN

Вложенный запрос может возвращать несколько значений одного столбца. Тогда его можно использовать в разделе `WHERE` совместно с оператором `IN`.

```sql
WHERE имя_столбца IN (вложенный запрос, возвращающий один столбец)
```

Оператор `IN` определяет, совпадает ли значение столбца с одним из значений, содержащихся во вложенном запросе. При этом логическое выражение после `WHERE` получает значение истина. Оператор `NOT IN` выполняет обратное действие – выражение истинно, если значение столбца не содержится во вложенном запросе.

**Пример**

Вывести информацию о книгах тех авторов, общее количество экземпляров книг которых не менее 12.

*Запрос:*

```sql
SELECT title, author, amount, price
FROM book
WHERE author IN (
        SELECT author 
        FROM book 
        GROUP BY author 
        HAVING SUM(amount) >= 12
      );
```

*Результат:*

```sql
+-----------------------+------------------+--------+--------+
| title                 | author           | amount | price  |
+-----------------------+------------------+--------+--------+
| Идиот                 | Достоевский Ф.М. | 10     | 460.00 |
| Братья Карамазовы     | Достоевский Ф.М. | 3      | 799.01 |
| Игрок                 | Достоевский Ф.М. | 10     | 480.50 |
| Стихотворения и поэмы | Есенин С.А.      | 15     | 650.00 |
+-----------------------+------------------+--------+--------+
```

Вложенный запрос отбирает двух авторов (Достоевского и Есенина). А в основном запросе для каждой записи таблицы `**book**` проверяется, входит ли автор книги в отобранный список, если входит - информация о книге включается в запрос.

### Вложенный запрос, операторы ANY и ALL

 Вложенный запрос, возвращающий несколько значений одного столбца, можно использовать для отбора записей с помощью операторов `ANY` и `ALL` совместно с операциями отношения (=, <>, <=, >=, <, >).

Операторы `ANY` и `ALL` используются в SQL для сравнения некоторого значения с результирующим набором вложенного запроса, состоящим из одного столбца. При этом тип данных столбца, возвращаемого вложенным запросом, должен совпадать с типом данных столбца (или выражения), с которым происходит сравнение.

При использовании оператора `ANY` в результирующую таблицу будут включены все записи, для которых  выражение со знаком отношения верно хотя бы для одного элемента результирующего запроса. Как работает оператор `ANY`:

- `amount > ANY (10, 12)` эквивалентно `amount > 10`
- `amount < ANY (10, 12)` эквивалентно `amount < 12`
- `amount = ANY (10, 12)` эквивалентно `(amount = 10) OR (amount = 12)`, а также `amount IN  (10,12)`
- `amount <> ANY (10, 12)` вернет все записи с любым значением `amount,` включая 10 и 12

При использовании оператора `ALL` в результирующую таблицу будут включены все записи, для которых  выражение со знаком отношения верно для всех элементов результирующего запроса. Как работает оператор `ALL`:

- `amount > ALL (10, 12)` эквивалентно `amount > 12`
- `amount < ALL (10, 12)` эквивалентно `amount < 10`
- `amount = ALL (10, 12)` не вернет ни одной записи, так как эквивалентно `(amount = 10) AND (amount = 12)`
- `amount <> ALL (10, 12)` вернет все записи кроме тех, в которых`amount равно 10 или 12`

**Важно!** Операторы `**ALL**` и `**ANY**` можно использовать т**олько с вложенными запросами**. В примерах выше (10, 12) приводится как результат вложенного запроса просто для того, чтобы показать как эти операторы работают. В запросах так записывать нельзя.

**Пример**

Вывести информацию о тех книгах, количество которых меньше самого маленького среднего количества книг каждого автора.

*Запрос:*

```sql
SELECT title, author, amount, price
FROM book
WHERE amount < ALL (
        SELECT AVG(amount) 
        FROM book 
        GROUP BY author 
      );
```

*Результат:*

```sql
+--------------------+------------------+--------+--------+
| title              | author           | amount | price  |
+--------------------+------------------+--------+--------+
| Мастер и Маргарита | Булгаков М.А.    | 3      | 670.99 |
| Братья Карамазовы  | Достоевский Ф.М. | 3      | 799.01 |
+--------------------+------------------+--------+--------+
```

**Пример**

Вывести информацию о тех книгах, количество которых меньше самого большого среднего количества книг каждого автора.

*Запрос:*

```sql
SELECT title, author, amount, price
FROM book
WHERE amount < ANY (
        SELECT AVG(amount) 
        FROM book 
        GROUP BY author 
      );
```

*Результат:*

```sql
+--------------------+------------------+--------+--------+
| title              | author           | amount | price  |
+--------------------+------------------+--------+--------+
| Мастер и Маргарита | Булгаков М.А.    | 3      | 670.99 |
| Белая гвардия      | Булгаков М.А.    | 5      | 540.50 |
| Идиот              | Достоевский Ф.М. | 10     | 460.00 |
| Братья Карамазовы  | Достоевский Ф.М. | 3      | 799.01 |
| Игрок              | Достоевский Ф.М. | 10     | 480.50 |
+--------------------+------------------+--------+--------+
```

### Вложенный запрос после SELECT

Вложенный запрос может располагаться после ключевого слова `SELECT`. В этом случае результат выполнения запроса выводится в отдельном столбце результирующей таблицы. При этом результатом запроса может быть только одно значение, тогда оно будет повторяться во всех строках. Также вложенный запрос может использоваться в выражениях.

**Пример**

Вывести информацию о книгах, количество экземпляров которых отличается от среднего количества экземпляров книг на складе более чем на 3,  а также указать среднее значение количества экземпляров книг.

*Запрос:*

```sql
SELECT title, author, amount, 
    (
     SELECT AVG(amount) 
     FROM book
    ) AS Среднее_количество 
FROM book
WHERE abs(amount - (SELECT AVG(amount) FROM book)) >3;
```

*Результат:*

```sql
+-----------------------+------------------+--------+--------------------+
| title                 | author           | amount | Среднее_количество |
+-----------------------+------------------+--------+--------------------+
| Мастер и Маргарита    | Булгаков М.А.    | 3      | 7.6667             |
| Братья Карамазовы     | Достоевский Ф.М. | 3      | 7.6667             |
| Стихотворения и поэмы | Есенин С.А.      | 15     | 7.6667             |
+-----------------------+------------------+--------+--------------------+
```

Во вложенном запросе вычисляется среднее количество экземпляров книг на складе. Этот запрос используется и в условии отбора, и для создания столбца **Среднее_количество** в результирующей таблице запроса. Значения  столбца одинаковы во всех строках, поскольку  вложенный запрос возвращает одно значение.

Среднее количество в виде дробного числа выглядит не очень правильно. Полученное значение можно [округлить "вниз"](https://stepik.org/lesson/297509/step/6?unit=279269) - до ближайшего меньшего целого.

*Запрос:*

```sql
SELECT title, author, amount, 
      FLOOR((SELECT AVG(amount) FROM book)) AS Среднее_количество 
FROM book
WHERE ABS(amount - (SELECT AVG(amount) FROM book)) >3;
```

*Результат:*

```sql
+-----------------------+------------------+--------+--------------------+
| title                 | author           | amount | Среднее_количество |
+-----------------------+------------------+--------+--------------------+
| Мастер и Маргарита    | Булгаков М.А.    | 3      | 7                  |
| Братья Карамазовы     | Достоевский Ф.М. | 3      | 7                  |
| Стихотворения и поэмы | Есенин С.А.      | 15     | 7                  |
+-----------------------+------------------+--------+--------------------+
```

## Запросы корректировки данных

### Добавление записей в таблицу

Добавление одной записи в таблицу осуществляется с помощью запроса `INSERT`, подробно рассмотренного в [первом уроке](https://stepik.org/lesson/297508/step/8?unit=279268). Запросы обязательно разделять точкой с запятой.

Допускается вставка нескольких записей одновременно, для этого используется SQL запрос следующего вида:

```sql
INSERT INTO имя_таблицы(столбец_1, столбец_2, ..., столбец_N)
VALUES
    (значение_1_1, значение_1_2, ..., значение_1_N),
    (значение_2_1, значение_2_2, ..., значение_2_N),
    ...
    (значение_M_1, значение_M_2, ..., значение_M_N);
```

Например, чтобы добавить в таблицу `**book**` две новые записи используется запрос:

```sql
INSERT INTO book (title, author, price, amount) 
VALUES 
    ('Война и мир','Толстой Л.Н.', 1070.20, 2),
    ('Анна Каренина', 'Толстой Л.Н.', 599.90, 3);
```

### Добавление записей из другой таблицы

С помощью запроса на добавление можно не только добавить в таблицу конкретные значения (список `VALUES`), но и записи из другой таблицы, отобранные с помощью запроса на выборку.  В этом случае вместо раздела `VALUES` записывается запрос на выборку, начинающийся с `SELECT`.  В нем можно использовать `WHERE, GROUP BY, ORDER BY`.

Правила соответствия между полями таблицы и вставляемыми значениями из запроса:

1. количество полей в таблице и количество полей в запросе должны совпадать;
2. должно существовать прямое соответствие между позицией одного и того же элемента в обоих списках, поэтому первый столбец запроса должен относиться к первому столбцу в списке столбцов таблицы, второй – ко второму столбцу и т.д.
3.  типы столбцов запроса должны быть совместимы с типами данных соответствующих столбцов таблицы ( целое число можно занести в поле типа `DECIMAL`, обратная операция – недопустима).

**Пример**

Занести все книги из таблицы `**supply**` в таблицу `**book**`.

*Запрос:*

```sql
INSERT INTO book (title, author, price, amount) 
SELECT title, author, price, amount 
FROM supply;

SELECT * FROM book;
```

*Результат:*

```sql
Affected rows: 4
Query result:
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
| 6       | Лирика                | Пастернак Б.Л.   | 518.99 | 2      |
| 7       | Черный человек        | Есенин С.А.      | 570.20 | 6      |
| 8       | Белая гвардия         | Булгаков М.А.    | 540.50 | 7      |
| 9       | Идиот                 | Достоевский Ф.М. | 360.80 | 3      |
+---------+-----------------------+------------------+--------+--------+
Affected rows: 9
```

С помощью этого запроса в таблицу `**book**` включены все книги из **`supply`**, даже те, которые в `**book** `уже есть («Белая гвардия» и «Идиот»). В результате в таблице одна и та же книга, например «Белая гвардия», имеет код 2 и 8. Для реляционной модели это нежелательная ситуация. Устранить эту проблему можно с помощью вложенных запросов, которые будут рассмотрены в следующем шаге.

### Добавление записей, вложенные запросы

В запросах на добавление можно использовать вложенные запросы.

**Пример**

Занести из таблицы `**supply**` в таблицу `**book**` только те книги, названия которых отсутствуют в таблице `**book.**`

*Запрос:*

```sql
INSERT INTO book (title, author, price, amount) 
SELECT title, author, price, amount 
FROM supply
WHERE title NOT IN (
        SELECT title 
        FROM book
      );

SELECT * FROM book;
```

*Результат:*

```sql
Affected rows: 2

Query result:
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
| 6       | Лирика                | Пастернак Б.Л.   | 518.99 | 2      |
| 7       | Черный человек        | Есенин С.А.      | 570.20 | 6      |
+---------+-----------------------+------------------+--------+--------+
```

Вложенным запросом отбираются все названия книг, которые есть в таблице `**book**`. Основным запросом `SELECT` из таблицы `**supply**` выбираются книги, названия которых нет в результате вложенного запроса. Отобранные записи добавляются в конец таблицы `**book**`запросом на добавление `INSERT`.

### Запросы на обновление

Под обновлением данных подразумевается изменение значений в существующих записях таблицы. При этом возможно как изменение значений полей в группе строк (даже всех строк таблицы), так и правка значения поля отдельной строки.

Изменение записей в таблице реализуется с помощью запроса `UPDATE`. Простейший запрос на  обновление выглядит так:

```sql
UPDATE таблица SET поле = выражение
```

где 
**таблица** – имя таблицы, в которой будут проводиться изменения;
**поле** – поле таблицы, в которое будет внесено изменение;
**выражение** – выражение,  значение которого будет занесено в поле.

**Пример**

Уменьшить на 30% цену книг в таблице `**book**`.

*Запрос:*

```sql
UPDATE book 
SET price = 0.7 * price;

SELECT * FROM book;
```

*Результат:*

```sql
Affected rows: 5
Query result:
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 469.69 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 378.35 | 5      |
| 3       | Идиот                 | Достоевский Ф.М. | 322.00 | 10     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 559.31 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 455.00 | 15     |
+---------+-----------------------+------------------+--------+--------+
```

С помощью запросов на обновление можно изменять не все записи в таблице (как в предыдущем запросе), а только часть из них. Для этого в запрос включается ключевое слово `WHERE`, после которого указывается условие отбора строк для изменения.

**Пример**

Уменьшить на 30% цену тех книг в таблице `**book**`, количество которых меньше 5.

*Запрос:*

```sql
UPDATE book 
SET price = 0.7 * price 
WHERE amount < 5;

SELECT * FROM book;
```

*Результат:*

```sql
Affected rows: 2
Query result:
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 469.69 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 559.31 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
+---------+-----------------------+------------------+--------+--------+
```

В этом запросе обновляется только 2 записи (цена книг «Мастер и Маргарита» и «Братья Карамазовы»).

### Запросы на обновление нескольких столбцов

Запросом `UPDATE` можно обновлять значения нескольких столбцов одновременно. В этом случае простейший запрос будет выглядеть так:

```sql
UPDATE таблица SET поле1 = выражение1, поле2 = выражение2
```

На складе, кроме хранения и получения книг, выполняется их оптовая продажа. Для реализации этого действия включим дополнительный столбец `**buy**` в таблицу `**book**`:

| **book_id**                        | **title**             | **author**       | **price**        | **amount** | **buy** |
| ---------------------------------- | --------------------- | ---------------- | ---------------- | ---------- | ------- |
| **INT PRIMARY KEY AUTO_INCREMENT** | **VARCHAR(50)**       | **VARCHAR(30)**  | **DECIMAL(8,2)** | **INT**    | int     |
| 1                                  | Мастер и Маргарита    | Булгаков М.А.    | 670.99           | 3          | 0       |
| 2                                  | Белая гвардия         | Булгаков М.А.    | 540.50           | 5          | 3       |
| 3                                  | Идиот                 | Достоевский Ф.М. | 460.00           | 10         | 8       |
| 4                                  | Братья Карамазовы     | Достоевский Ф.М. | 799.01           | 2          | 0       |
| 5                                  | Стихотворения и поэмы | Есенин С.А.      | 650.00           | 15         | 18      |

**Пример**

В столбце `**buy**` покупатель указывает количество книг, которые он хочет приобрести. Для каждой книги, выбранной покупателем, необходимо уменьшить ее количество на складе на указанное в столбце`**buy**` количество, а в столбец `**buy**` занести 0.

*Запрос:*

```sql
UPDATE book 
SET amount = amount - buy,
    buy = 0;

SELECT * FROM book;
```

*Результат:*

```sql
Affected rows: 3
Query result:
+---------+-----------------------+------------------+--------+--------+-----+
| book_id | title                 | author           | price  | amount | buy |
+---------+-----------------------+------------------+--------+--------+-----+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      | 0   |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 2      | 0   |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 2      | 0   |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      | 0   |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | -3     | 0   |
+---------+-----------------------+------------------+--------+--------+-----+
```

Как видно из таблицы, без проверки данных, которые занесены в столбец, нельзя запускать запрос на обновление (может получиться отрицательное значение количества).

### Запросы на обновление нескольких таблиц 

В запросах на обновление можно использовать несколько таблиц, но тогда

- для столбцов, имеющих одинаковые имена, необходимо указывать имя таблицы, к которой они относятся, например, `**book.price**` – столбец `**price** `из таблицы `**book**`, **`supply.price`** – столбец `**price**` из таблицы `**supply**`;
- все таблицы, используемые в запросе, нужно перечислить после ключевого слова `UPDATE`;
- в запросе обязательно условие `WHERE`, в котором указывается условие при котором обновляются данные.

**Пример**

Если в таблице `**supply**` есть те же книги, что и в таблице` **book**`, добавлять эти книги в таблицу `**book**` не имеет смысла. Необходимо увеличить их количество на значение столбца `**amount**`таблицы `**supply**`.

*Запрос:*

```sql
UPDATE book, supply 
SET book.amount = book.amount + supply.amount
WHERE book.title = supply.title AND book.author = supply.author;

SELECT * FROM book;
```

*Результат:*

```sql
Affected rows: 2
Query result:
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 12     |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 13     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
+---------+-----------------------+------------------+--------+--------+
```

В этом запросе увеличилось количество двух книг: «Белая гвардия», которая в `**supply**` имеет ту же цену, и «Идиот», но цена этой книги в таблицах `**book**` и **`supply`** отличается. Для этой книги нужно пересчитать цену.

### Запросы на удаление

Запросы корректировки данных позволяют удалить одну или несколько записей из  таблицы. Простейший запрос на удаление имеет вид:

```sql
DELETE FROM таблица;
```

Этот запрос удаляет все записи из указанной после `FROM` таблицы.

**Пример**

После того, как информация о книгах из таблицы `**supply**` перенесена в `**book**` , необходимо очистить таблицу  `**supply**`.

*Запрос:*

```sql
DELETE FROM supply;

SELECT * FROM supply;
```

*Результат:*

```sql
Affected rows: 4
Affected rows: 0
```

Из таблицы удалены все записи. Запрос на выборку отобрал 0 записей.

Запрос на удаления позволяет удалить не все записи таблицы, а только те, которые удовлетворяют условию, указанному после ключевого слова `WHERE`:

```sql
DELETE FROM таблица
WHERE условие;
```

**Пример**

Удалить из таблицы `**supply**` все книги, названия которых есть в таблице `**book**`.

*Запрос:*

```sql
DELETE FROM supply 
WHERE title IN (
        SELECT title 
        FROM book
      );


SELECT * FROM supply;
```

Результат:

```sql
Affected rows: 2

Query result:
+-----------+--------------------------+------------------+--------+--------+
| supply_id | title                    | author           | price  | amount |
+-----------+--------------------------+------------------+--------+--------+
| 1         | Лирика                   | Пастернак Б.Л.   | 518.99 | 2      |
| 2         | Черный человек           | Есенин С.А.      | 570.20 | 6      |
+-----------+--------------------------+------------------+--------+--------+
```

Из таблицы `**supply**` удалены две записи о книгах «Белая гвардия» и «Идиот».

### Запросы на создание таблицы

Новая таблица может быть создана на основе данных из другой таблицы. Для этого используется запрос `SELECT`, результирующая таблица которого и будет новой таблицей базы данных. При этом имена столбцов запроса становятся именами столбцов новой таблицы. Запрос на создание новой таблицы имеет вид:

```sql
CREATE TABLE имя_таблицы AS
SELECT ...
```

**Пример**

Создать таблицу заказ (`**ordering**`), куда включить авторов и названия тех книг, количество экземпляров которых в таблице `**book**` меньше 4. Для всех книг указать одинаковое количество экземпляров 5.

*Запрос:*

```sql
CREATE TABLE ordering AS
SELECT author, title, 5 AS amount
FROM book
WHERE amount < 4;

SELECT * FROM ordering;
```

*Результат:*

```sql
Affected rows: 2
Query result:
+------------------+--------------------+--------+
| author           | title              | amount |
+------------------+--------------------+--------+
| Булгаков М.А.    | Мастер и Маргарита | 5      |
| Достоевский Ф.М. | Братья Карамазовы  | 5      |
+------------------+--------------------+--------+
```

При создании таблицы можно использовать вложенные запросы как после `SELECT`, так и после `WHERE`.

**Пример**

Создать таблицу заказ (`**ordering**`), куда включить авторов и названия тех книг, количество экземпляров которых в таблице `**book**` меньше 4. Для всех книг указать одинаковое значение - среднее количество экземпляров книг в таблице `**book**`.

*Запрос:*

```sql
CREATE TABLE ordering AS
SELECT author, title, 
   (
    SELECT ROUND(AVG(amount)) 
    FROM book
   ) AS amount
FROM book
WHERE amount < 4;

SELECT * FROM ordering;
```

*Результат:*

```sql
Affected rows: 2
Query result:
+------------------+--------------------+--------+
| author           | title              | amount |
+------------------+--------------------+--------+
| Булгаков М.А.    | Мастер и Маргарита | 7      |
| Достоевский Ф.М. | Братья Карамазовы  | 7      |
+------------------+--------------------+--------+
```

## Таблица "Командировки", запросы на выборку

### **Оператор LIMIT**

Для ограничения вывода записей в SQL используется оператор `LIMIT` , после которого указывается количество строк.  Результирующая таблица будет иметь количество строк не более указанного после `LIMIT`. `LIMIT` размещается после раздела `ORDER BY`.

Как правило, этот оператор используется, чтобы отобрать заданное количество отсортированных строк результата запроса. 

**Пример**

Вывести информацию о первой командировке из таблицы `**trip**`. "Первой" считать командировку с самой ранней датой начала.

*Запрос:*

```sql
SELECT *
FROM trip
ORDER BY  date_first
LIMIT 1;
```

*Результат:*

```sql
+---------+--------------+--------+----------+------------+------------+
| trip_id | name         | city   | per_diem | date_first | date_last  |
+---------+--------------+--------+----------+------------+------------+
| 1       | Баранов П.Е. | Москва | 700.00   | 2020-01-12 | 2020-01-17 |
+---------+--------------+--------+----------+------------+------------+
```

**Важно.** Оператор `LIMIT` нужно использовать очень осторожно. Например, если бы в таблице `**trip**` было несколько командировок с одинаковой датой начала, этот запрос работал бы НЕВЕРНО. Это связано с тем, что заранее не известно точное значение таких командировок.

### DATEDIFF

Для вычитания двух дат используется функция `**DATEDIFF(дата_1, дата_2)**`, результатом которой является количество дней между **дата_1** и **дата_2**. Например,

```sql
DATEDIFF('2020-04-01', '2020-03-28')=4

DATEDIFF('2020-05-09','2020-05-01')=8

DATEDIFF(date_last, date_first)
```

### MONTH

Для того, чтобы выделить номер месяца из даты используется функция `**MONTH(дата)**`.

Например, `**MONTH('2020-04-12') = 4**`.

Если определяется месяц для значений столбца `**date_first**`, то используется запись `**MONTH(date_first)**`

### MONTHNAME

1. Для того, чтобы выделить название месяца из даты используется функция `**MONTHNAME(дата)**`, которая возвращает название месяца на английском языке для указанной даты. Например, `**MONTHNAME('2020-04-12')='April'**`.
2. Если группировка осуществляется по вычисляемому столбцу (в данном случае «вычисляется» название месяца), то после `GROUP BY`можно указать как вычисляемое выражение, так и имя столбца, заданное с помощью `AS`. Важно отметить, что последний вариант (указать имя столбца) нарушает стандарт по порядку выполнения запросов, но иногда может встречаться на реальных платформах.

В SQL есть функции, которые позволяют выделить часть даты: день(`**DAY()**`), месяц (`**MONTH()**`), год(`**YEAR()**`) . Например:

```sql
DAY('2020-02-01') = 1
MONTH('2020-02-01') = 2
YEAR('2020-02-01') = 2020
```

## Таблица "Нарушения ПДД", запросы корректировки

### Использование временного имени таблицы (алиаса)

*Теоретический материал для этого шага подготовлен* [Михаилом Захаров](https://stepik.org/users/15955624)ым *. Большое ему спасибо!*

Чтобы не писать название таблицы каждый раз, удобно использовать алиасы.

Алиас, это псевдоним, который мы присваивали столбцам после ключевого слова `**AS**`([шаг](https://stepik.org/lesson/297509/step/4?unit=279269)). Алиасы так же можно использовать и для таблиц. Это становится актуальным, при увеличении числа используемых таблиц, их иногда может быть и 5 и 10 и более. Псевдонимы помогают сделать запрос чище и читабельнее.

Для присваивания псевдонима существует 2 варианта: 

- с использованием ключевого слова `**AS**` 

```sql
FROM fine AS f, traffic_violation AS tv
```

- а так же и без него

```sql
FROM fine f, traffic_violation tv
```

После присвоения таблице алиаса, он используется во всех разделах запроса, в котором алиас задан. Например:

```
WHERE f.violation = tv.violation
```

**Пример**

Для тех, кто уже оплатил штраф, вывести информацию о том, изменялась ли стандартная сумма штрафа.

*Запрос:*

```sql
SELECT  f.name, f.number_plate, f.violation, 
   if(
    f.sum_fine = tv.sum_fine, "Стандартная сумма штрафа", 
    if(
      f.sum_fine < tv.sum_fine, "Уменьшенная сумма штрафа", "Увеличенная сумма штрафа"
    )
  ) AS description               
FROM  fine f, traffic_violation tv
WHERE tv.violation = f.violation and f.sum_fine IS NOT Null;
```

*Результат:* 

```sql
+---------------+--------------+----------------------------------+--------------------------+
| name          | number_plate | violation                        | description              |
+---------------+--------------+----------------------------------+--------------------------+
| Баранов П.Е.  | Р523ВТ       | Превышение скорости(от 40 до 60) | Уменьшенная сумма штрафа |
| Абрамова К.А. | О111АВ       | Проезд на запрещающий сигнал     | Стандартная сумма штрафа |
| Яковлев Г.Р.  | Т330ТТ       | Превышение скорости(от 20 до 40) | Стандартная сумма штрафа |
+---------------+--------------+----------------------------------+--------------------------+
```

## Группировка данных по нескольким столбцам

В разделе `GROUP BY` можно указывать несколько столбцов, разделяя их запятыми. Тогда к одной группе будут относиться записи, у которых значения столбцов, входящих в группу, равны. Рассмотрим группировку по нескольким столбцам на примере следующего запроса:

```sql
SELECT name, number_plate, violation, count(*)
FROM fine
GROUP BY name, number_plate, violation;
```

\1. Сначала записи таблицы **`fine`** разделяются на группы. В каждую группу включаются строки, у которых равны значения в столбцах `**name**`, `**number_plate**` и `**violation**` соответственно. Получается 6 групп. 

![img](https://ucarecdn.com/ff298302-7c99-4ecc-8245-d26c32c1d524/)

\2. Затем вычисляется функция `**count(\*)**`, которая определяет количество записей в каждой группе. Получается, что к первым двум группам относятся по две записи, ко всем остальным - по одной.

![img](https://ucarecdn.com/4bb9e222-d1ba-4806-8fd8-b7eb8c64f11b/)

**Важно!** В разделе `**GROUP BY**` нужно перечислять все НЕАГРЕГИРОВАННЫЕ столбцы (к которым не применяются групповые функции) из `**SELECT**`.

# Запросы SQL к связанным таблицам

## Связи между таблицами

### Создание таблицы с внешними ключами

При создании зависимой таблицы (таблицы, которая содержит внешние ключи) необходимо учитывать, что :

- каждый внешний ключ должен иметь такой же тип данных, как связанное поле главной таблицы (в наших примерах это `**INT)**`;
- необходимо указать главную для нее таблицу и столбец, по которому осуществляется связь:

```sql
FOREIGN KEY (связанное_поле_зависимой_таблицы)  
REFERENCES главная_таблица (связанное_поле_главной_таблицы)
```

По умолчанию любой столбец, кроме ключевого, может содержать значение `**NULL**`. При создании таблицы это можно переопределить, используя ограничение` **NOT NULL**` для этого столбца:

```sql
CREATE TABLE таблица (
    столбец_1 INT NOT NULL, 
    столбец_2 VARCHAR(10) 
);
```

 В созданной таблице в `**столбец_1**` не может содержать пустое значение, а` **столбец_2**` - может.

Для внешних ключей рекомендуется устанавливать ограничение `**NOT NULL**` (если это совместимо с другими опциями, которые будут рассмотрены в следующем шаге).

 **Пример**

Создать таблицу **`book`** следующей структуры:

| **Поле**    | **Тип, описание**                | **Связи**                                                    |
| ----------- | -------------------------------- | ------------------------------------------------------------ |
| `book_id`   | `INT PRIMARY KEY AUTO_INCREMENT` |                                                              |
| `title`     | `VARCHAR(50)`                    |                                                              |
| `author_id` | `INT `                           | внешний ключ: главная таблица `**author**`, связанный столбец `**author.author_id**`, пустое значение не допускается |
| `price`     | `DECIMAL(8, 2)`                  |                                                              |
| `amount`    | `INT`                            |                                                              |

*Запрос:*

```sql
CREATE TABLE book (
    book_id INT PRIMARY KEY AUTO_INCREMENT, 
    title VARCHAR(50), 
    author_id INT NOT NULL, 
    price DECIMAL(8,2), 
    amount INT, 
    FOREIGN KEY (author_id)  REFERENCES author (author_id) 
);
```

### Действия при удалении записи главной таблицы

С помощью выражения `ON DELETE` можно установить действия, которые выполняются для записей подчиненной таблицы при удалении связанной строки из главной таблицы. При удалении можно установить следующие опции:

- `CASCADE`: автоматически удаляет строки из зависимой таблицы при удалении связанных строк в главной таблице.
- `SET NULL`: при удалении связанной строки из главной таблицы устанавливает для столбца внешнего ключа значение **`NULL`**. (В этом случае столбец внешнего ключа должен поддерживать установку` **NULL**`).
- `SET DEFAULT` похоже на `SET NULL` за тем исключением, что значение внешнего ключа устанавливается не в `NULL,` а в значение по умолчанию для данного столбца.
- `RESTRICT`: отклоняет удаление строк в главной таблице при наличии связанных строк в зависимой таблице.

**Важно!** Если для столбца установлена опция `SET NULL`, то при его описании нельзя задать ограничение на пустое значение.

**Пример**

Будем считать, что при удалении автора из таблицы `**author**`, необходимо удалить все записи о книгах из таблицы `**book**`, написанные этим автором. Данное действие необходимо прописать при создании таблицы.

*Запрос:*

```sql
CREATE TABLE book (
    book_id INT PRIMARY KEY AUTO_INCREMENT, 
    title VARCHAR(50), 
    author_id INT NOT NULL, 
    price DECIMAL(8,2), 
    amount INT, 
    FOREIGN KEY (author_id)  REFERENCES author (author_id) ON DELETE CASCADE
);
```

## Запросы на выборку, соединение таблиц

### Соединение INNER JOIN

Оператор внутреннего соединения `INNER JOIN` соединяет две таблицы. Порядок таблиц для оператора неважен, поскольку оператор является симметричным.

```sql
SELECT
 ...
FROM
    таблица_1 INNER JOIN  таблица_2
    ON условие
...
```

Результат запроса формируется так:

- каждая строка одной таблицы сопоставляется с каждой строкой второй таблицы;
- для полученной «соединённой» строки проверяется условие соединения;
- если условие истинно, в таблицу результата добавляется соответствующая «соединённая» строка;

**Пример**

Вывести название книг и их авторов.

*Запрос:*

```sql
SELECT title, name_author
FROM 
    author INNER JOIN book
    ON author.author_id = book.author_id;
```

Поскольку поля `**author_id**` в таблицах `**book**` и **`author`** называются одинаково, необходимо в запросах указывать полную ссылку на них (`**book.author_id**` и `**author.author_id**`).

*Результат:*

```sql
+-----------------------+------------------+
| title                 | name_author      |
+-----------------------+------------------+
| Мастер и Маргарита    | Булгаков М.А.    |
| Белая гвардия         | Булгаков М.А.    |
| Идиот                 | Достоевский Ф.М. |
| Братья Карамазовы     | Достоевский Ф.М. |
| Игрок                 | Достоевский Ф.М. |
| Стихотворения и поэмы | Есенин С.А.      |
| Черный человек        | Есенин С.А.      |
| Лирика                | Пастернак Б.Л.   |
+-----------------------+------------------+
```

В данном запросе осуществляется соединение главной таблицы **`author`** и зависимой таблицы `**book**` по ключевому столбцу` **author.author_id**` и внешнему ключу `**book.author_id**`. При этом в результирующую таблицу запроса включаются все строки, в которых значения этих столбцов совпадают. Другими словами строки зависимой таблицы `**book**` дополняются фамилией и инициалами авторов из таблицы `**author**`.

### Внешнее соединение LEFT и RIGHT OUTER JOIN

Оператор внешнего соединения `LEFT OUTER JOIN` (можно использовать `LEFT JOIN`) соединяет две таблицы. Порядок таблиц для оператора важен, поскольку оператор не является симметричным.

```sql
SELECT
 ...
FROM
    таблица_1 LEFT JOIN  таблица_2
    ON условие
...
```

Результат запроса формируется так:

1. в результат включается внутреннее соединение (`INNER JOIN`) первой и второй таблицы в соответствии с условием;
2. затем в результат добавляются те записи первой таблицы, которые не вошли во внутреннее соединение на шаге 1, для таких записей соответствующие поля второй таблицы заполняются значениями `NULL`.

Соединение `RIGHT JOIN` действует аналогично, только в пункте 2 первая таблица меняется на вторую и наоборот.

**Пример**

Вывести название всех книг каждого автора, если книг некоторых авторов в данный момент нет на складе – вместо названия книги указать `Null`.

*Запрос:*

```sql
SELECT name_author, title 
FROM author LEFT JOIN book
     ON author.author_id = book.author_id
ORDER BY name_author;     
```

Результат:

```sql
+------------------+-----------------------+
| name_author      | title                 |
+------------------+-----------------------+
| Булгаков М.А.    | Мастер и Маргарита    |
| Булгаков М.А.    | Белая гвардия         |
| Достоевский Ф.М. | Игрок                 |
| Достоевский Ф.М. | Идиот                 |
| Достоевский Ф.М. | Братья Карамазовы     |
| Есенин С.А.      | Стихотворения и поэмы |
| Есенин С.А.      | Черный человек        |
| Лермонтов М.Ю.   | NULL                  |
| Пастернак Б.Л.   | Лирика                |
+------------------+-----------------------+
```

Так как в таблице` **book**` нет книг Лермонтова, напротив этой фамилии стоит `Null`.

### **Перекрестное соединение CROSS JOIN**

Оператор перекрёстного соединения, или декартова произведения `CROSS JOIN` (в запросе вместо ключевых слов можно поставить запятую между таблицами) соединяет две таблицы. Порядок таблиц для оператора неважен, поскольку оператор является симметричным. Его структура:

```sql
SELECT
 ...
FROM
    таблица_1 CROSS JOIN  таблица_2
...
```

или

```sql
SELECT
 ...
FROM
    таблица_1, таблица_2
...
```

Результат запроса формируется так: каждая строка одной таблицы соединяется с каждой строкой другой таблицы, формируя в результате все возможные сочетания строк двух таблиц.

Например, запрос:

```sql
SELECT name_author, name_genre
FROM 
    author, genre;
```

каждому автору из таблицы `**author**` поставит в соответствие все возможные жанры из таблицы `**genre**`:

```sql
+------------------+-------------+
| name_author      | name_genre  |
+------------------+-------------+
| Булгаков М.А.    | Роман       |
| Булгаков М.А.    | Поэзия      |
| Булгаков М.А.    | Приключения |
| Достоевский Ф.М. | Роман       |
| Достоевский Ф.М. | Поэзия      |
| Достоевский Ф.М. | Приключения |
| Есенин С.А.      | Роман       |
| Есенин С.А.      | Поэзия      |
| Есенин С.А.      | Приключения |
| Пастернак Б.Л.   | Роман       |
| Пастернак Б.Л.   | Поэзия      |
| Пастернак Б.Л.   | Приключения |
| Лермонтов М.Ю.   | Роман       |
| Лермонтов М.Ю.   | Поэзия      |
| Лермонтов М.Ю.   | Приключения |
+------------------+-------------+
```

\1. Для генерации случайной даты можно к первому числу года ('2020-01-01') прибавить целое случайное число в интервале от 0 до 365.

Генерации случайных чисел в интервале от 0 до 1 (не включительно) осуществляется с помощью функции `RAND()`. Если эту функцию умножить на 365, то она будет генерировать вещественные числа от 0 до 365 (не включительно). Осталось только отбросить дробную часть. Это можно сделать с помощью функции `FLOOR()`, которая возвращает наибольшее целое число, меньшее или равное указанному числовому значению. Таким образом, случайное число от 0 до 365 можно получить с помощью выражения:

```
FLOOR(RAND() * 365)
```

**Важно!** Даты должны быть за 2020 год, первое число года - 1 января 2020 года.

\2. Для сложения даты с числом используется функция:

```sql
DATE_ADD(дата, INTERVAL число единица_измерения),

где
  единица_измерения (использовать прописные буквы) – это день (DAY), месяц(MONTH), неделя(WEEK) и пр., 
  число – целое число,
  дата – значение даты или даты и времени.
```

Функция к **дате** прибавляет указанное **число**, выраженное в днях, месяцах и пр. , в зависимости от заданного интервала, и возвращает новую дату.

Например:

```sql
DATE_ADD('2020-02-02', INTERVAL 45 DAY) возвращает 18 марта 2020 года
DATE_ADD('2020-02-02', INTERVAL 6 MONTH) возвращает 2 августа 2020 года
```

### Запросы на выборку из нескольких таблиц

Запрос на выборку может выбирать данные из двух и более таблиц базы данных. При этом таблицы должны быть логически связаны между собой. Для каждой пары таблиц, включаемых в запрос, необходимо указать свой оператор соединения. Наиболее распространенным является внутреннее соединение `INNER JOIN`, поэтому в примерах будем использовать его.

Пусть таблицы связаны между собой следующим образом:

![img](https://ucarecdn.com/ce01d392-5623-4e6c-aa60-2f58246a2b7f/)

тогда запрос на выборку для этих таблиц будет иметь вид:

```sql
SELECT
 ...
FROM
    first 
    INNER JOIN  second ON first.first_id = second.first_id
    INNER JOIN  third  ON second.second_id = third.second_id
...
```

Если же таблицы связаны так:

![img](https://ucarecdn.com/5da25bff-06fd-42f7-a32e-3fc65ca67954/)

то запрос на выборку выглядит следующим образом:

```sql
SELECT
 ...
FROM
    first 
    INNER JOIN  third ON first.first_id = third.first_id
    INNER JOIN second ON third.second_id = second.second_id 
...
```

В этом случае рекомендуется соединение таблиц записывать последовательно, «по кругу»: `**first → third → second**`.

**Пример**

Вывести информацию о тех книгах, их авторах и жанрах, цена которых принадлежит интервалу от 500 до 700 рублей включительно.

*Запрос:*

```sql
SELECT title, name_author, name_genre, price, amount
FROM
    author 
    INNER JOIN  book ON author.author_id = book.author_id
    INNER JOIN genre ON genre.genre_id = book.genre_id
WHERE price BETWEEN 500 AND 700;
```

*Результат:*

```sql
+-----------------------+----------------+------------+--------+--------+
| title                 | name_author    | name_genre | price  | amount |
+-----------------------+----------------+------------+--------+--------+
| Мастер и Маргарита    | Булгаков М.А.  | Роман      | 670.99 | 3      |
| Белая гвардия         | Булгаков М.А.  | Роман      | 540.50 | 5      |
| Стихотворения и поэмы | Есенин С.А.    | Поэзия     | 650.00 | 15     |
| Черный человек        | Есенин С.А.    | Поэзия     | 570.20 | 6      |
| Лирика                | Пастернак Б.Л. | Поэзия     | 518.99 | 2      |
+-----------------------+----------------+------------+--------+--------+
```

### Запросы для нескольких таблиц с группировкой

В запросах с групповыми функциями могут использоваться несколько таблиц, между которыми используются различные типы соединений.

**Пример**

Вывести количество различных книг каждого автора. Информацию отсортировать в алфавитном порядке по фамилиям авторов.

*Запрос:*

```sql
SELECT name_author, count(title) AS Количество
FROM 
    author INNER JOIN book
    on author.author_id = book.author_id
GROUP BY name_author
ORDER BY name_author;    
```

*Результат*

```sql
+------------------+------------+
| name_author      | Количество |
+------------------+------------+
| Булгаков М.А.    | 2          |
| Достоевский Ф.М. | 3          |
| Есенин С.А.      | 2          |
| Пастернак Б.Л.   | 1          |
+------------------+------------+
```

При использовании соединения `INNER JOIN` мы не можем узнать, что книг Лермонтова на складе нет, но предполагается, что они могут быть. Чтобы автор Лермонтов был включен в результат, нужно изменить соединение таблиц.

*Запрос:*

```sql
SELECT name_author, count(title) AS Количество
FROM 
    author LEFT JOIN book
    on author.author_id = book.author_id
GROUP BY name_author
ORDER BY name_author;   
```

*Результат:*

```sql
+------------------+------------+
| name_author      | Количество |
+------------------+------------+
| Булгаков М.А.    | 2          |
| Достоевский Ф.М. | 3          |
| Есенин С.А.      | 2          |
| Лермонтов М.Ю.   | 0          |
| Пастернак Б.Л.   | 1          |
+------------------+------------+
```

### Запросы для нескольких таблиц со вложенными запросами

В запросах, построенных на нескольких таблицах, можно использовать вложенные запросы. Вложенный запрос может быть включен: после ключевого слова `SELECT`, после `FROM` и в условие отбора после `WHERE (HAVING)`.

**Пример**

Вывести авторов, общее количество книг которых на складе максимально.

Это достаточно сложный запрос, поэтому будем решать его по шагам (реализуя каждый запрос по отдельности), а потом объединим все запросы в один.

**Шаг 1.** Найдем суммарное количество книг на складе по каждому автору. Поскольку фамилии автора в этой таблице нет, то группировку будем осуществлять по `**author_id**`.

*Запрос:*

```sql
SELECT author_id, SUM(amount) AS sum_amount FROM book GROUP BY author_id
```

*Результат:*

```sql
+-----------+------------+
| author_id | sum_amount |
+-----------+------------+
| 1         | 8          |
| 2         | 23         |
| 3         | 21         |
| 4         | 2          |
+-----------+------------+
```

**Шаг 2**. В результирующей таблице предыдущего запроса необходимо найти максимальное значение, то есть 23. Для этого запросу, созданному на шаге 1, необходимо присвоить имя (например, `**query_in**`) и использовать его в качестве таблицы-источника после `FROM`. Затем уже находить максимум по столбцу `**sum_amount**`.

*Запрос:* 

```sql
SELECT MAX(sum_amount) AS max_sum_amount
FROM 
    (
     SELECT author_id, SUM(amount) AS sum_amount 
     FROM book 
     GROUP BY author_id
    ) query_in
```

*Результат:*

```sql
+----------------+
| max_sum_amount |
+----------------+
| 23             |
+----------------+
```

**Шаг 3**. Выведем фамилию автора и общее количество книг для него.

*Запрос:* 

```sql
SELECT name_author, SUM(amount) as Количество
FROM 
    author INNER JOIN book
    on author.author_id = book.author_id
GROUP BY name_author
```

*Результат:*

```sql
+------------------+------------+
| name_author      | Количество |
+------------------+------------+
| Булгаков М.А.    | 8          |
| Достоевский Ф.М. | 23         |
| Есенин С.А.      | 21         |
| Пастернак Б.Л.   | 2          |
+------------------+------------+
```

**Шаг 4**. Включим запрос с шага 2 в условие отбора запроса с шага 3. И получим всех авторов, общее количество книг которых максимально.

 *Запрос:* 

```sql
SELECT name_author, SUM(amount) as Количество
FROM 
    author INNER JOIN book
    on author.author_id = book.author_id
GROUP BY name_author
HAVING SUM(amount) = 
     (/* вычисляем максимальное из общего количества книг каждого автора */
      SELECT MAX(sum_amount) AS max_sum_amount
      FROM 
          (/* считаем количество книг каждого автора */
            SELECT author_id, SUM(amount) AS sum_amount 
            FROM book GROUP BY author_id
          ) query_in
      );
```

*Результат:*

```sql
+------------------+------------+
| name_author      | Количество |
+------------------+------------+
| Достоевский Ф.М. | 23         |
+------------------+------------+
```

### Вложенные запросы в операторах соединения

Вложенные запросы могут использоваться в операторах соединения `JOIN`. При этом им необходимо присваивать имя, которое записывается сразу после закрывающей скобки вложенного запроса.

```sql
SELECT
 ...
FROM
    таблица ... JOIN  
       (
        SELECT ...
       ) имя_вложенного_запроса
    ON условие
...
```

Вложенный запрос может стоять как справа, так и слева от оператора `JOIN`. Допускается использование двух запросов в операторах соединения.

**Пример**

Вывести авторов, пишущих книги в самом популярном жанре. Указать этот жанр.

Самым популярным считать жанр, общее количество экземпляров книг которого на складе максимально. Таких жанров может быть несколько, если они имеют одинаковое максимальное значение общего количества экземпляров. Только для этого шага изменена запись в таблице `**book**`.

| **book_id** | **title** | **author_id** | **genre_id** | **price** | **amount** |
| ----------- | --------- | ------------- | ------------ | --------- | ---------- |
| 8           | Лирика    | 4             | 2            | 518.9910  | 10         |

А также добавлены новые записи:

| **book_id** | **title**            | **author_id** | **genre_id** | **price** | **amount** |
| ----------- | -------------------- | ------------- | ------------ | --------- | ---------- |
| 9           | Герой нашего времени | 5             | 3            | 570.59    | 2          |
| 10          | Доктор Живаго        | 4             | 3            | 740.50    | 5          |

Рассмотрим реализацию этого запроса по шагам.

**Шаг 1.** Найдем общее количество книг по каждому жанру, отсортируем его по убыванию и ограничим вывод одной строкой. Рекомендуется, если запрос будет использоваться в качестве вложенного (особенно в операциях соединения), вычисляемым полям запроса давать собственное имя.

*Запрос:*

```sql
SELECT genre_id, SUM(amount) AS sum_amount
FROM book
GROUP BY genre_id
ORDER BY sum_amount DESC
LIMIT 1
```

*Результат:*

```sql
+---------------+------------+
|  genre_id     | sum_amount |
+---------------+------------+
| 1             | 31         |
+---------------+------------+
```

Кажется, что, уже используя этот запрос, можно получить **`id`** самого популярного жанра. Но это не так, поскольку несколько жанров могут иметь одинаковую популярность. Поэтому нам необходим запрос, который отберет ВСЕ жанры, суммарное количество книг которых равно `**sum_amount**`.

**Шаг 2.** Используя запрос с предыдущего шага, найдем `**id**` самых популярных жанров.

*Запрос:*

```sql
SELECT query_in_1.genre_id
FROM 
    (/* выбираем код жанра и количество произведений, относящихся к нему */
      SELECT genre_id, SUM(amount) AS sum_amount
      FROM book
      GROUP BY genre_id 
    )query_in_1
    INNER JOIN
    (/* выбираем запись, в которой указан код жанр с максимальным количеством книг */
      SELECT genre_id, SUM(amount) AS sum_amount
      FROM book
      GROUP BY genre_id
      ORDER BY sum_amount DESC
      LIMIT 1
     ) query_in_2
     ON query_in_1.sum_amount= query_in_2.sum_amount              
  
```

*Результат:*

```sql
+----------+
| genre_id |
+----------+
| 1        |
| 2        |
+----------+
```

**Шаг 3.** Используя запрос с шага 2, выведем фамилии авторов, которые пишут в самых популярных жанрах, и названия этих жанров. В этом запросе обязательно выполнить группировку по фамилиям авторов и `**id**` жанров, так как без этого фамилии авторов будут повторяться, поскольку в таблице **`book`** есть разные книги, написанные автором в одном жанре.

*Запрос:*

```sql
SELECT  name_author, name_genre
FROM 
    author 
    INNER JOIN book ON author.author_id = book.author_id
    INNER JOIN genre ON  book.genre_id = genre.genre_id
GROUP BY name_author,name_genre, genre.genre_id
HAVING genre.genre_id IN
         (/* выбираем автора, если он пишет книги в самых популярных жанрах*/
          SELECT query_in_1.genre_id
          FROM 
              ( /* выбираем код жанра и количество произведений, относящихся к нему */
                SELECT genre_id, SUM(amount) AS sum_amount
                FROM book
                GROUP BY genre_id
               )query_in_1
          INNER JOIN 
              ( /* выбираем запись, в которой указан код жанр с максимальным количеством книг */
                SELECT genre_id, SUM(amount) AS sum_amount
                FROM book
                GROUP BY genre_id
                ORDER BY sum_amount DESC
                LIMIT 1
               ) query_in_2
          ON query_in_1.sum_amount= query_in_2.sum_amount
         );   
```

**Важно!**

1. Обратите внимание, что в группировку включен столбец`**genre_id**`, который используется в `HAVING.` Это связано с тем, что в `HAVING` можно использовать либо столбцы, перечисленные в `GROUP BY`, либо вычисляемые с помощью групповых функций столбцы. Добавление столбца `**genre_id**`не влияет на группировку, так как между названием жанра и его **id** - взаимно-однозначное соответствие.
2. Название столбца` **genre_id** `задается с указанием имени таблицы (`**genre.genre_id**`), так как этот столбец входит в структуру двух таблиц `**book**` и **`genre`**. Для этого запроса можно было бы указать и `**book.genre_id**`, так как эти таблицы связаны внутренним соединением `INNER JOIN` и имеют одинаковые значения в полях `**genre.genre_id**` и `**book.genre_id**`.

*Результат:*

```sql
+------------------+------------+
| name_author      | name_genre |
+------------------+------------+
| Достоевский Ф.М. | Роман      |
| Булгаков М.А.    | Роман      |
| Пастернак Б.Л.   | Поэзия     |
| Есенин С.А.      | Поэзия     |
+------------------+------------+
```

### Операция соединение, использование USING()

*Данный шаг добавлен по предложениям пользователей* ([Валерий Родькин](https://stepik.org/users/60542727), [Todor Illia](https://stepik.org/users/33149099) и другие)*.*

При описании соединения таблиц с помощью `**JOIN**` в некоторых случаях вместо **`ON`** и следующего за ним условия можно использовать оператор **`USING()`**.

`**USING**` позволяет указать набор столбцов, которые есть в обеих объединяемых таблицах. Если база данных хорошо спроектирована, а каждый внешний ключ имеет такое же имя, как и соответствующий первичный ключ (например, `**genre.genre_id = book.genre_id**`), тогда можно использовать предложение **`USING`** для реализации операции `**JOIN**`. 

При этом после **`SELECT`**, при использовании столбцов из `**USING()**`, необязательно указывать, из какой именно таблицы берется столбец.

**Пример**

Вывести название книг, фамилии и `**id**` их авторов.

*Запрос:*

Вариант с `**ON**`

```sql
SELECT title, name_author, author.author_id /* явно указать таблицу - обязательно */
FROM 
    author INNER JOIN book
    ON author.author_id = book.author_id;
```

Вариант с `**USING**`

```sql
SELECT title, name_author, author_id /* имя таблицы, из которой берется author_id, указывать не обязательно*/
FROM 
    author INNER JOIN book
    USING(author_id);
```

*Результат (одинаковый для обоих запросов):*

```sql
+-----------------------+------------------+-----------+
| title                 | name_author      | author_id |
+-----------------------+------------------+-----------+
| Мастер и Маргарита    | Булгаков М.А.    | 1         |
| Белая гвардия         | Булгаков М.А.    | 1         |
| Идиот                 | Достоевский Ф.М. | 2         |
| Братья Карамазовы     | Достоевский Ф.М. | 2         |
| Игрок                 | Достоевский Ф.М. | 2         |
| Стихотворения и поэмы | Есенин С.А.      | 3         |
| Черный человек        | Есенин С.А.      | 3         |
| Лирика                | Пастернак Б.Л.   | 4         |
+-----------------------+------------------+-----------+
```

Запись условия соединения с **`ON`** является более общим случаем, так как

- позволяет задавать соединение не только по одноименным полям;
- позволяет использовать произвольное условие на соединение таблиц, при этом в условие может включаться произвольное выражение, например, можно указать связь двух таблиц по двум и более столбцам.

**Пример**

В таблице **supply** занесена информация о книгах, поступивших на склад.

| **supply_id** | **title**      | **author**       | **price** | **amount** |
| ------------- | -------------- | ---------------- | --------- | ---------- |
| 1             | Доктор Живаго  | Пастернак Б.Л.   | 618.99    | 3          |
| 2             | Черный человек | Есенин С.А.      | 570.20    | 6          |
| 3             | Евгений Онегин | Пушкин А.С.      | 440.80    | 5          |
| 4             | Идиот          | Достоевский Ф.М. | 360.80    | 3          |

Если в таблицах `**supply**` и `**book**` есть одинаковые книги, вывести их название и автора. При этом учесть, что у нескольких авторов могут быть книги с одинаковым названием.

**Важно.** В данном примере для соединения `**book**` и `**supply**` использовать `**USING**` нельзя, так как: 

- в таблице `**book**` фамилий авторов вообще нет (их необходимо получить из таблицы **`author`**, столбец **`name_author`**), а в таблице `**supply**` фамилии занесены в столбец `**author**`;
- для однозначной идентификации книги нужно указать, что совпадают не только названия, но и авторы книг.

*Запрос:*

```sql
SELECT book.title, name_author
FROM 
    author 
    INNER JOIN book USING (author_id)   
    INNER JOIN supply ON book.title = supply.title 
                         and author.name_author = supply.author;
```

*Результат:*

```sql
+----------------+------------------+
| title          | name_author      |
+----------------+------------------+
| Идиот          | Достоевский Ф.М. |
| Черный человек | Есенин С.А.      |
+----------------+------------------+
```

## Запросы корректировки, соединение таблиц

### Запросы на обновление, связанные таблицы

В запросах на обновление можно использовать связанные таблицы:

```sql
UPDATE таблица_1
     ... JOIN таблица_2
     ON выражение
     ...
SET ...   
WHERE ...;
```

При этом исправлять данные можно во всех используемых в запросе таблицах.

**Пример**

Для книг, которые уже есть на складе (в таблице**` book`**) по той же цене, что и в поставке (`**supply**`), увеличить количество на значение, указанное в поставке, а также обнулить количество этих книг в поставке.

Этот запрос должен отобрать строки из таблиц **`book`**и `**supply**` такие, что у них совпадают и автор, и название книги. Но в таблице `**supply**` фамилия автора записана не числом (`**id**`), а текстом. Следовательно, чтобы выполнить сравнение по фамилии автора нужно "подтянуть" таблицу **`author`**, которая связана с **`book`**по столбцу `**author_id**`. И в логическом выражении, описывающем соединение таблиц, можно будет использовать столбцы из таблиц **`book, author`**и `**supply**`. 

Если таблицы логически связаны по двум и более столбцам (на рисунке связи обозначены линиями), возможно через другие таблицы, условие соединение будет включать связи по нужным столбцам через логический оператор `**AND**`. Например, для следующих таблиц логическую связь по названию и автору:

![img](https://ucarecdn.com/3c953b71-fad4-40c0-8ae2-6e43a3e201d0/)

условие соединения можно записать в виде:

```sql
book INNER JOIN author ON author.author_id = book.author_id
     INNER JOIN supply ON book.title = supply.title 
                          and supply.author = author.name_author
```

*Запрос:*

```sql
UPDATE book 
     INNER JOIN author ON author.author_id = book.author_id
     INNER JOIN supply ON book.title = supply.title 
                         and supply.author = author.name_author
SET book.amount = book.amount + supply.amount,
    supply.amount = 0   
WHERE book.price = supply.price;

SELECT * FROM book;

SELECT * FROM supply;
```

*Результат:*

```sql
Affected rows: 4

Query result:
+---------+-----------------------+-----------+----------+--------+--------+
| book_id | title                 | author_id | genre_id | price  | amount |
+---------+-----------------------+-----------+----------+--------+--------+
| 1       | Мастер и Маргарита    | 1         | 1        | 670.99 | 3      |
| 2       | Белая гвардия         | 1         | 1        | 540.50 | 12     |
| 3       | Идиот                 | 2         | 1        | 460.00 | 10     |
| 4       | Братья Карамазовы     | 2         | 1        | 799.01 | 3      |
| 5       | Игрок                 | 2         | 1        | 480.50 | 10     |
| 6       | Стихотворения и поэмы | 3         | 2        | 650.00 | 15     |
| 7       | Черный человек        | 3         | 2        | 570.20 | 12     |
| 8       | Лирика                | 4         | 2        | 518.99 | 2      |
+---------+-----------------------+-----------+----------+--------+--------+
Affected rows: 8

Query result:
+-----------+-----------------------+------------------+--------+--------+
| supply_id | title                 | author           | price  | amount |
+-----------+-----------------------+------------------+--------+--------+
| 1         | Доктор Живаго         | Пастернак Б.Л.   | 380.80 | 4      |
| 2         | Черный человек        | Есенин С.А.      | 570.20 | 0      |
| 3         | Белая гвардия         | Булгаков М.А.    | 540.50 | 0      |
| 4         | Идиот                 | Достоевский Ф.М. | 360.80 | 3      |
| 5         | Стихотворения и поэмы | Лермонтов М.Ю.   | 255.90 | 4      |
| 6         | Остров сокровищ       | Стивенсон Р.Л.   | 599.99 | 5      |
+-----------+-----------------------+------------------+--------+--------+
Affected rows: 6
```

Под нужное нам условие подходят две книги «Белая гвардия» Булгакова и «Черный человек» Есенина. В таблице `**book**` их количество увеличилось, а в таблице `**supply**` - обнулилось.

### Запросы на добавление, связанные таблицы

Запросом на добавление можно добавить записи, отобранные с помощью запроса на выборку, который включает несколько таблиц:

```sql
INSERT INTO таблица (список_полей)
SELECT список_полей_из_других_таблиц
FROM 
    таблица_1 
    ... JOIN таблица_2 ON ...
    ...
```

**Пример**

В таблице `**supply**` есть новые книги, которых на складе еще не было. Прежде чем добавлять их в таблицу `**book**`, необходимо из таблицы `**supply**`отобрать новых авторов, если таковые имеются.

*Запрос:*

```sql
SELECT name_author, supply.author
FROM 
    author 
    RIGHT JOIN supply ON author.name_author = supply.author;
```

Поскольку таблица `**author**` и поле в таблице `**supply**` называются одинаково, желательно указывать полную ссылку на поле (`**supply.author**`), чтобы запрос был более читабельным.

*Результат:*

```sql
+------------------+------------------+
| name_author      | author           |
+------------------+------------------+
| Булгаков М.А.    | Булгаков М.А.    |
| Достоевский Ф.М. | Достоевский Ф.М. |
| Есенин С.А.      | Есенин С.А.      |
| Пастернак Б.Л.   | Пастернак Б.Л.   |
| Лермонтов М.Ю.   | Лермонтов М.Ю.   |
| None             | Стивенсон Р.Л.   |
+------------------+------------------+
```

Выполнив правое внутреннее соединение таблиц, получили значение` Null (None)` в поле `**name_author**` в строке того автора, которого нет в таблице` **author**`, в нашем случае это Стивенсон.

Теперь достаточно в запросе задать условие отбора, и список новых авторов готов для включения в таблицу `**author**`.

*Запрос:*

```sql
SELECT supply.author
FROM 
    author 
    RIGHT JOIN supply on author.name_author = supply.author
WHERE name_author IS Null;
```

*Результат:*

```sql
+----------------+
| author         |
+----------------+
| Стивенсон Р.Л. |
+----------------+
```

### Запрос на добавление, связанные таблицы

Следующий шаг - добавить новые записи о книгах, которые есть в таблице `**supply**` и нет в таблице **`book`**. (В таблицах `**supply**` и `**book**` сохранены изменения предыдущих шагов). Поскольку в таблице `**supply**` не указан жанр книги, оставить его пока пустым (занести значение `Null`).

**Пример**

Прежде всего необходимо сформировать запрос с полями, которые соответствуют полям таблицы `**book**`, так как использовать только таблицу `**supply**` нельзя - в ней вместо кода автора стоит его фамилия. 

*Запрос:*

```sql
SELECT title, author_id, price, amount
FROM 
    author 
    INNER JOIN supply ON author.name_author = supply.author;
```

*Результат:*

```sql
+-----------------------+-----------+--------+--------+
| title                 | author_id | price  | amount |
+-----------------------+-----------+--------+--------+
| Доктор Живаго         | 4         | 380.80 | 4      |
| Черный человек        | 3         | 570.20 | 0      |
| Белая гвардия         | 1         | 540.50 | 0      |
| Идиот                 | 2         | 360.80 | 0      |
| Стихотворения и поэмы | 5         | 255.90 | 4      |
| Остров сокровищ       | 6         | 599.99 | 5      |
+-----------------------+-----------+--------+--------+
```

Далее необходимо отобрать только новые книги из таблицы `**supply**`. Как видно из таблицы с результатами запроса, в тех записях, которые нужно добавить, значения столбца `**amount**` не равны 0 (количество уже учтенных книг обнулены предыдущим запросом). Добавим это условие в запрос.

*Запрос:*

```sql
SELECT title, author_id, price, amount
FROM 
    author 
    INNER JOIN supply ON author.name_author = supply.author
WHERE amount <> 0;
```

*Результат:*

```sql
+-----------------------+-----------+--------+--------+
| title                 | author_id | price  | amount |
+-----------------------+-----------+--------+--------+
| Доктор Живаго         | 4         | 380.80 | 4      |
| Стихотворения и поэмы | 5         | 255.90 | 4      |
| Остров сокровищ       | 6         | 599.99 | 5      |
+-----------------------+-----------+--------+--------+
```

### Запрос на обновление, вложенные запросы

После того, как новые книги добавлены в таблицу `**book**`, нужно указать к какому жанру они относятся. Для этого используется запрос на обновление, в котором можно указать значения столбцов из других таблиц, либо использовать вложенные запросы для получения этих значений.

**Пример**

Задать для книги Пастернака «Доктор Живаго» жанр «Роман».

Если мы знаем код этой книги в таблице `**book** `(в нашем случае это 9) и код жанра «Роман» в таблице `**genre**` (это 1), запрос будет очень простым.

*Запрос:*

```sql
UPDATE book
SET genre_id = 1
WHERE book_id = 9;

SELECT * FROM book;
```

*Результат:*

```sql
Affected rows: 1

Query result:
+---------+-----------------------+-----------+----------+--------+--------+
| book_id | title                 | author_id | genre_id | price  | amount |
+---------+-----------------------+-----------+----------+--------+--------+
| 1       | Мастер и Маргарита    | 1         | 1        | 670.99 | 3      |
| 2       | Белая гвардия         | 1         | 1        | 540.50 | 12     |
| 3       | Идиот                 | 2         | 1        | 437.11 | 13     |
| 4       | Братья Карамазовы     | 2         | 1        | 799.01 | 3      |
| 5       | Игрок                 | 2         | 1        | 480.50 | 10     |
| 6       | Стихотворения и поэмы | 3         | 2        | 650.00 | 15     |
| 7       | Черный человек        | 3         | 2        | 570.20 | 12     |
| 8       | Лирика                | 4         | 2        | 518.99 | 2      |
| 9       | Доктор Живаго         | 4         | 1        | 380.80 | 4      |
| 10      | Стихотворения и поэмы | 5         | NULL     | 255.90 | 4      |
| 11      | Остров сокровищ       | 6         | NULL     | 599.99 | 5      |
+---------+-----------------------+-----------+----------+--------+--------+
```

Более сложным будет запрос, если известно только название жанра (результат будет точно таким же):

*Запрос:*

```sql
UPDATE book
SET genre_id = 
      (
       SELECT genre_id 
       FROM genre 
       WHERE name_genre = 'Роман'
      )
WHERE book_id = 9;

SELECT * FROM book;
```

### Каскадное удаление записей связанных таблиц

При создании таблицы для внешних ключей с помощью `ON DELETE` [устанавливаются опции](https://stepik.org/lesson/308885/step/9?unit=291011), которые определяют действия , выполняемые при удалении связанной строки из главной таблицы.

В частности, `ON DELETE CASCADE` автоматически удаляет строки из зависимой таблицы при удалении связанных строк в главной таблице.

В таблице `**book**` эта опция установлена для поля **`author_id`**.

**Пример**

Удалим из таблицы `**author**` всех авторов, фамилия которых начинается на «Д», а из таблицы `**book**` - все книги этих авторов.

*Запрос:*

```sql
DELETE FROM author
WHERE name_author LIKE "Д%";

SELECT * FROM author;

SELECT * FROM book;
```

*Результат:*

```sql
Affected rows: 1

Query result:
+-----------+----------------+
| author_id | name_author    |
+-----------+----------------+
| 1         | Булгаков М.А.  |
| 3         | Есенин С.А.    |
| 4         | Пастернак Б.Л. |
| 5         | Лермонтов М.Ю. |
| 6         | Стивенсон Р.Л. |
+-----------+----------------+
Affected rows: 5

Query result:
+---------+-----------------------+-----------+----------+--------+--------+
| book_id | title                 | author_id | genre_id | price  | amount |
+---------+-----------------------+-----------+----------+--------+--------+
| 1       | Мастер и Маргарита    | 1         | 1        | 670.99 | 3      |
| 2       | Белая гвардия         | 1         | 1        | 540.50 | 12     |
| 6       | Стихотворения и поэмы | 3         | 2        | 650.00 | 15     |
| 7       | Черный человек        | 3         | 2        | 570.20 | 12     |
| 8       | Лирика                | 4         | 2        | 518.99 | 2      |
| 9       | Доктор Живаго         | 4         | 1        | 380.80 | 4      |
| 10      | Стихотворения и поэмы | 5         | 2        | 255.90 | 4      |
| 11      | Остров сокровищ       | 6         | 3        | 599.99 | 5      |
+---------+-----------------------+-----------+----------+--------+--------+
```

Одним запросом удаляются связанные записи из главной и зависимой таблицы. В нашем случае удалился автор Достоевский и все его книги.

### Удаление записей главной таблицы с сохранением записей в зависимой

При создании таблицы для внешних ключей с помощью `ON DELETE` [устанавливаются опции](https://stepik.org/lesson/308885/step/9?unit=291011), которые определяют действия, выполняемые при удалении связанной строки из главной таблицы.

Если задано `SET NULL`, то при удалении связанной строки из главной таблицы в зависимой, в столбце внешнего ключа, устанавливается значение **`NULL`**. (При этом в столбце внешнего ключа должно быть допустимо значение **`NULL`**)

В таблице `**book**` эта опция установлена на поле **`genre_id`**.

**Пример**

Удалим из таблицы `**genre**` все жанры, название которых заканчиваются на «я» , а в таблице `**book**` - для этих жанров установим значение `Null`.

*Запрос:*

```sql
DELETE FROM genre
WHERE name_genre LIKE "%я";

SELECT * FROM genre;

SELECT * FROM book;
```

*Результат:*

```sql
Affected rows: 2

Query result:
+----------+------------+
| genre_id | name_genre |
+----------+------------+
| 1        | Роман      |
+----------+------------+
Affected rows: 1

Query result:
+---------+-----------------------+-----------+----------+--------+--------+
| book_id | title                 | author_id | genre_id | price  | amount |
+---------+-----------------------+-----------+----------+--------+--------+
| 1       | Мастер и Маргарита    | 1         | 1        | 670.99 | 3      |
| 2       | Белая гвардия         | 1         | 1        | 540.50 | 12     |
| 3       | Идиот                 | 2         | 1        | 437.11 | 13     |
| 4       | Братья Карамазовы     | 2         | 1        | 799.01 | 3      |
| 5       | Игрок                 | 2         | 1        | 480.50 | 10     |
| 6       | Стихотворения и поэмы | 3         | Null     | 650.00 | 15     |
| 7       | Черный человек        | 3         | Null     | 570.20 | 12     |
| 8       | Лирика                | 4         | Null     | 518.99 | 2      |
| 9       | Доктор Живаго         | 4         | 1        | 380.80 | 4      |
| 10      | Стихотворения и поэмы | 5         | Null     | 255.90 | 4      |
| 11      | Остров сокровищ       | 6         | Null     | 599.99 | 5      |
+---------+-----------------------+-----------+----------+--------+--------+
Affected rows: 11
```

В нашем случае удалились жанры «Поэзия» и «Приключения».

### Удаление записей, использование связанных таблиц

При удалении записей из таблицы можно использовать информацию из других связанных с ней таблиц. В этом случае синтаксис запроса имеет вид:

```sql
DELETE FROM таблица_1
USING 
    таблица_1 
    INNER JOIN таблица_2 ON ...
WHERE ...
```

**Пример**

Удалить всех авторов из таблицы `**author**`, у которых есть книги, количество экземпляров которых меньше 3. Из таблицы `**book**` удалить все книги этих авторов.

*Запрос:*

```sql
DELETE FROM author
USING 
    author 
    INNER JOIN book ON author.author_id = book.author_id
WHERE book.amount < 3;

SELECT * FROM author;

SELECT * FROM book;
```

*Результат:*

```sql
Affected rows: 1

Query result:
+-----------+------------------+
| author_id | name_author      |
+-----------+------------------+
| 1         | Булгаков М.А.    |
| 2         | Достоевский Ф.М. |
| 3         | Есенин С.А.      |
| 5         | Лермонтов М.Ю.   |
| 6         | Стивенсон Р.Л.   |
+-----------+------------------+
Affected rows: 5

Query result:
+---------+-----------------------+-----------+----------+--------+--------+
| book_id | title                 | author_id | genre_id | price  | amount |
+---------+-----------------------+-----------+----------+--------+--------+
| 1       | Мастер и Маргарита    | 1         | 1        | 670.99 | 3      |
| 2       | Белая гвардия         | 1         | 1        | 540.50 | 12     |
| 3       | Идиот                 | 2         | 1        | 437.11 | 13     |
| 4       | Братья Карамазовы     | 2         | 1        | 799.01 | 3      |
| 5       | Игрок                 | 2         | 1        | 480.50 | 10     |
| 6       | Стихотворения и поэмы | 3         | 2        | 650.00 | 15     |
| 7       | Черный человек        | 3         | 2        | 570.20 | 12     |
| 10      | Стихотворения и поэмы | 5         | 2        | 255.90 | 4      |
| 11      | Остров сокровищ       | 6         | 3        | 599.99 | 5      |
+---------+-----------------------+-----------+----------+--------+--------+
```

Книги из таблицы `**book**` будут удалены автоматически, так как для столбца `**author_id**` из таблицы `**book**` установлено [каскадное удаление записей](https://stepik.org/lesson/308887/step/6?unit=291013).

## База данных "Интернет магазин"

### Проектирование концептуальной модели базы данных

**Шаг 1.** Детально проанализировать предметную область и выделить те информационные объекты, которые будут храниться в базе данных (выделены зеленым):

> *В интернет-магазине продаются* **книги***. Каждая книга имеет название, написана одним* **автором***, относится к одному* **жанру***, имеет определенную цену. В магазине в наличии есть несколько экземпляров каждой книги.* 
>
> **Покупатель** *регистрируется на сайте интернет-магазина, задает свое имя и фамилию,  электронную почту и* **город** *проживания (для упрощения считаем, что человек не может поменять свой город проживания). Он может сформировать один или несколько* **заказов***, для каждого заказа написать какие-то пожелания. Каждый заказ включает одну или несколько книг, каждую книгу можно заказать в нескольких экземплярах. Затем заказ проходит ряд последовательных* **этапов** *(операций): оплачивается, упаковывается, передается курьеру или транспортной компании для транспортировки и, наконец, доставляется покупателю. Фиксируется дата каждой операции. Для каждого города известно среднее время доставки книг.*
>
> *При этом в магазине ведется учет книг, при покупке их количество уменьшается, при поступлении товара увеличивается, при исчерпании количества* – *оформляется заказ и пр.*

**Шаг 2.** Для каждого выделенного информационного объекта указать его характеристики, для этого:

а) сначала выделить их в описании предметной области (синий цвет): 

> *В интернет-магазине продаются* **книги***. Каждая книга имеет **название**, написана одним* **автором***, относится к одному* **жанру***, имеет определенную **цену**. В магазине в наличии есть **несколько экземпляров** каждой книги.* 
>
> **Покупатель** *регистрируется на сайте интернет-магазина, задает свое **имя и фамилию**,  **электронную почту** и* **город** *проживания. Он может сформировать один или несколько* **заказов***, для каждого заказа написать какие-то **пожелания**. Каждый заказ включает **одну или несколько книг**, каждую книгу можно заказать **в нескольких экземплярах**. Затем заказ проходит ряд последовательных* **этапов***(операций): оплачивается, упаковывается, передается курьеру или транспортной компании для транспортировки и, наконец, доставляется покупателю. Фиксируется **дата каждой операции**. Для каждого города известно **среднее время доставки книг**.*
>
> *При этом в магазине ведется учет книг, при покупке их количество уменьшается, при поступлении товара увеличивается, при исчерпании количества* – *оформляется заказ и пр.*

б) затем связать их с информационным объектом: 

- **Книга** – название, количество, цена;
- **Автор** – фамилия и инициалы;
- **Жанр** – название;
- **Покупатель (клиент)** – фамилия и имя, электронная почта;
- **Город** – название, среднее время доставки;
- **Заказ** – код заказа, пожелания;
- **Этап** – название этапов.

в) перечислить характеристики, которые остались не привязанными к информационным объектам (к ним необходимо вернуться при реализации связей между таблицами): 

- книги в заказе;
- количество книг в заказе;
- дата каждой операции.

**Шаг 3.** Нарисовать схему, на которой изобразить информационные объекты в виде прямоугольников:

![img](https://ucarecdn.com/055576f4-5c29-4ee6-a836-2cc4af782e27/)

 

**Шаг 4.** Установить связи между информационными объектами. Связь «один ко многим» обозначить в виде →, «многие ко многим» –  ↔.

- Каждая **книга** написана одним **автором**, каждый **автор** написал несколько **книг**, следовательно между этими таблицами связь «один ко многим»:

![img](https://ucarecdn.com/e1ca410d-e61c-46ac-aa01-8a170e5c53b4/)

- Каждая **книга** может включаться в несколько **заказов**, один **заказ** может содержать несколько **книг**, между этими таблицами связь «многие ко многим»:

![img](https://ucarecdn.com/29da39a3-ae36-4bb4-a473-32e50a30cf1f/)

- Каждый **клиент** может сформировать несколько **заказов**, каждый **заказ** формируется только одним **клиентом**:

![img](https://ucarecdn.com/8cc1f9b4-4851-4f65-8d82-9449c1d879b0/)

### Запросы на основе трех и более связанных таблиц

**Пример**

Вывести фамилии всех клиентов, которые заказали книгу Булгакова «Мастер и Маргарита».

*Запрос:*

Этот запрос строится на основе нескольких таблиц, для удобства нужно определить фрагмент логической схемы базы данных, на основе которой строится запрос. В нашем случае выбираются название книги из таблицы `**book**` и фамилия клиента из таблицы `**client**`. Эти таблицы между собой непосредственно не связаны, поэтому нужно добавить «связующие» таблицы **`buy`** и `**buy_book**`:

 

Для соединения этих таблиц используется `INNER JOIN`. Для удобства рекомендуется связи описывать последовательно: `**client** `→ `**buy** `→ `**buy_book** `→ `**book**`. А для соединения использовать пару **первичный ключ** и **внешний ключ** соответствующих таблиц. Например, соединение таблиц `**client** `и `**buy**` осуществляется по условию **`client.client_id = buy.client_id`**.

Чтобы не усложнять схему, будем считать, что нам известен **id** Булгакова (это 1)

```sql
SELECT DISTINCT name_client
FROM 
    client 
    INNER JOIN buy ON client.client_id = buy.client_id
    INNER JOIN buy_book ON buy_book.buy_id = buy.buy_id
    INNER JOIN book ON buy_book.book_id=book.book_id
WHERE title ='Мастер и Маргарита' and author_id = 1;                    
```

В запросе отбираются уникальные клиенты (`DISTINCT`) так как один и тот же клиент мог заказать одну и ту же книгу несколько раз.

*Результат:*

```sql
+---------------+
| name_client   |
+---------------+
| Баранов Павел |
| Абрамова Катя |
+---------------+
```

### **Оператор UNION**

Оператор `**UNION**` используется для объединения двух и более SQL запросов, его синтаксис:

```sql
SELECT столбец_1_1, столбец_1_2, ...
FROM 
  ...
UNION
SELECT столбец_2_1, столбец_2_2, ...
FROM 
  ...
```

или

```sql
SELECT столбец_1_1, столбец_1_2, ...
FROM 
  ...
UNION ALL
SELECT столбец_2_1, столбец_2_2, ...
FROM 
  ...
```

Важно отметить, что каждый из `**SELECT**` должен иметь в своем запросе одинаковое количество столбцов и совместимые типы возвращаемых данных. Каждый запрос может включать разделы `**WHERE**`, `**GROUP BY**` и пр.

В результате выполнения этой конструкции будет выведена таблица, имена столбцов которой соответствуют именам столбцов в первом запросе. А в таблице результата сначала отображаются записи-результаты первого запроса, а затем второго. Если указано ключевое слово `**ALL**`, то в результат включаются все записи запросов, в противном случае - различные.

**Пример**

Вывести всех клиентов, которые делали заказы или в этом, или в предыдущем году.

На этом примере рассмотрим разницу между `**UNION**` и `**UNION ALL**`.

С `**UNION** `клиенты будут выведены без повторений:

```
SELECT name_client
FROM 
    buy_archive
    INNER JOIN client USING(client_id)
UNION
SELECT name_client
FROM 
    buy 
    INNER JOIN client USING(client_id)
+-----------------+
| name_client     |
+-----------------+
| Баранов Павел   |
| Абрамова Катя   |
| Яковлева Галина |
| Семенонов Иван  |
+-----------------+
Affected rows: 4
```

C `**UNION ALL**` будут выведены клиенты с повторением (для тех, кто заказывал книги в обоих годах, а также несколько раз в одном году)

```
SELECT name_client
FROM 
    buy_archive
    INNER JOIN client USING(client_id)
UNION ALL
SELECT name_client
FROM 
    buy 
    INNER JOIN client USING(client_id)
+-----------------+
| name_client     |
+-----------------+
| Баранов Павел   |
| Баранов Павел   |
| Абрамова Катя   |
| Абрамова Катя   |
| Абрамова Катя   |
| Яковлева Галина |
| Яковлева Галина |
| Баранов Павел   |
| Абрамова Катя   |
| Абрамова Катя   |
| Баранов Павел   |
| Баранов Павел   |
| Абрамова Катя   |
| Семенонов Иван  |
+-----------------+
Affected rows: 14
```

**Пример**

Вывести информацию об оплаченных заказах за предыдущий и текущий год, информацию отсортировать по `**client_id**`.

*Запрос:*

```sql
SELECT buy_id, client_id, book_id, date_payment, amount, price
FROM 
    buy_archive
UNION ALL
SELECT buy.buy_id, client_id, book_id, date_step_end, buy_book.amount, price
FROM 
    book 
    INNER JOIN buy_book USING(book_id)
    INNER JOIN buy USING(buy_id) 
    INNER JOIN buy_step USING(buy_id)
    INNER JOIN step USING(step_id)                  
WHERE  date_step_end IS NOT Null and name_step = "Оплата"  
```

*Результат:*

```sql
+--------+-----------+---------+--------------+--------+--------+
| buy_id | client_id | book_id | date_payment | amount | price  |
+--------+-----------+---------+--------------+--------+--------+
| 2      | 1         | 1       | 2019-02-21   | 2      | 670.60 |
| 2      | 1         | 3       | 2019-02-21   | 1      | 450.90 |
| 1      | 2         | 2       | 2019-02-10   | 2      | 520.30 |
| 1      | 2         | 4       | 2019-02-10   | 3      | 780.90 |
| 1      | 2         | 3       | 2019-02-10   | 1      | 450.90 |
| 3      | 4         | 4       | 2019-03-05   | 4      | 780.90 |
| 3      | 4         | 5       | 2019-03-05   | 2      | 480.90 |
| 4      | 1         | 6       | 2019-03-12   | 1      | 650.00 |
| 5      | 2         | 1       | 2019-03-18   | 2      | 670.60 |
| 5      | 2         | 4       | 2019-03-18   | 1      | 780.90 |
| 1      | 1         | 3       | 2020-02-20   | 1      | 460.00 |
| 1      | 1         | 7       | 2020-02-20   | 2      | 570.20 |
| 1      | 1         | 1       | 2020-02-20   | 1      | 670.99 |
| 2      | 3         | 8       | 2020-02-28   | 2      | 518.99 |
| 3      | 2         | 1       | 2020-03-05   | 1      | 670.99 |
| 3      | 2         | 2       | 2020-03-05   | 1      | 540.50 |
| 3      | 2         | 3       | 2020-03-05   | 2      | 460.00 |
+--------+-----------+---------+--------------+--------+--------+
```

В результат включены сначала записи архивной таблицы, а затем информация об оплаченных заказах текущего года. Для того, чтобы изменить порядок следования записей в объединенном запросе, можно использовать **сортировку** по всем объединенным записям. В этом случае ключевые слова `**ORDER BY**` указываются после последнего запроса: 

```sql
SELECT buy_id, client_id, book_id, date_payment, amount, price
FROM 
    buy_archive
UNION ALL
SELECT buy.buy_id, client_id, book_id, date_step_end, buy_book.amount, price
FROM 
    book 
    INNER JOIN buy_book USING(book_id)
    INNER JOIN buy USING(buy_id) 
    INNER JOIN buy_step USING(buy_id)
    INNER JOIN step USING(step_id)                  
WHERE  date_step_end IS NOT Null and name_step = "Оплата"
ORDER BY client_id
```

*Результат:*

```sql
+--------+-----------+---------+--------------+--------+--------+
| buy_id | client_id | book_id | date_payment | amount | price  |
+--------+-----------+---------+--------------+--------+--------+
| 2      | 1         | 3       | 2019-02-21   | 1      | 450.90 |
| 2      | 1         | 1       | 2019-02-21   | 2      | 670.60 |
| 1      | 1         | 3       | 2020-02-20   | 1      | 460.00 |
| 1      | 1         | 7       | 2020-02-20   | 2      | 570.20 |
| 4      | 1         | 6       | 2019-03-12   | 1      | 650.00 |
| 1      | 1         | 1       | 2020-02-20   | 1      | 670.99 |
| 3      | 2         | 1       | 2020-03-05   | 1      | 670.99 |
| 3      | 2         | 2       | 2020-03-05   | 1      | 540.50 |
| 3      | 2         | 3       | 2020-03-05   | 2      | 460.00 |
| 5      | 2         | 4       | 2019-03-18   | 1      | 780.90 |
| 5      | 2         | 1       | 2019-03-18   | 2      | 670.60 |
| 1      | 2         | 3       | 2019-02-10   | 1      | 450.90 |
| 1      | 2         | 4       | 2019-02-10   | 3      | 780.90 |
| 1      | 2         | 2       | 2019-02-10   | 2      | 520.30 |
| 2      | 3         | 8       | 2020-02-28   | 2      | 518.99 |
| 3      | 4         | 5       | 2019-03-05   | 2      | 480.90 |
| 3      | 4         | 4       | 2019-03-05   | 4      | 780.90 |
+--------+-----------+---------+--------------+--------+--------+
```



# Базы данных и SQL запросы

Для выбора случайных вопросов можно отсортировать вопросы в случайном порядке:

```sql
ORDER BY RAND()
```

\1. Чтобы выделить крайние левые `**n** `символов из строки используется функция `**LEFT(строка, n)**`:

```sql
LEFT("abcde", 3) -> "abc"
```

\2. Соединение строк осуществляется с помощью функции `**CONCAT(строка_1, строка_2)**`:

```sql
CONCAT("ab","cd") -> "abcd"
```

\3. Поле `**is_correct**` - имеет тип `**BOOLEAN**`. Если ответ верный (`**TRUE**`), то в нем хранится 1, если неверный (`**FALSE**`), то в нем хранится 0. Можно заметить, что суммирование этого поля (при верно установленных связях) позволит посчитать количество верных ответов.

Для того, чтобы вставить текущую дату используйте функцию `**NOW()**`.

Для удаления таблицы используется SQL запрос `DROP`:

```sql
DROP TABLE таблица;
```

Рассмотрим, как происходит формирование списка абитуриентов, проходящих по конкурсу на образовательные программы. 

В таблицу `**applicant_order**` для пояснения включены столбцы «План набора» и «Результат». Каждая программа имеет свой план набора, например, план набора образовательной программы с **`id`** 1 – 2 человека. Проходящими по конкурсу считаются первые два человека в списке  отсортированных по итоговому баллу абитуриентов, подавших заявление на образовательную программу. Это абитуриенты с `**id**` 3 и 2. Аналогично отбираются абитуриенты на остальные образовательные программы. В таблице все проходящие по конкурсу выделены зеленым цветом.

| **program_id** | **план набора** | **enrollee_id** | **itog** | **Результат**             |
| -------------- | --------------- | --------------- | -------- | ------------------------- |
| 1              | 2               | 3               | 235      | рекомендован к зачислению |
| 1              | 2               | 2               | 226      | рекомендован к зачислению |
| 1              | 2               | 1               | 219      |                           |
| 2              | 1               | 6               | 276      | рекомендован к зачислению |
| 2              | 1               | 3               | 235      |                           |
| 2              | 1               | 2               | 226      |                           |
| 3              | 2               | 6               | 270      | рекомендован к зачислению |
| 3              | 2               | 4               | 239      | рекомендован к зачислению |
| 3              | 2               | 5               | 200      |                           |
| 4              | 3               | 6               | 270      | рекомендован к зачислению |
| 4              | 3               | 3               | 247      | рекомендован к зачислению |
| 4              | 3               | 5               | 200      | рекомендован к зачислению |

Для отбора рекомендованных к зачислению студентов можно разработать различные алгоритмы. Мы реализуем несколько SQL запросов. В первом запросе вставим в таблицу `**applicant_order**` новый столбец для последовательной нумерации строк. 

Для изменения структуры таблицы используется оператор `ALTER TABLE`. С его помощью можно вставить новый столбец, удалить существующий, переименовать столбец и пр.

Для вставки нового столбца используется SQL запросы:

```sql
ALTER TABLE таблица ADD имя_столбца тип; - вставляет столбец после последнего
ALTER TABLE таблица ADD имя_столбца тип FIRST; - вставляет столбец перед первым
ALTER TABLE таблица ADD имя_столбца тип AFTER имя_столбца_1; - вставляет столбец после укзанного столбца
```

Для удаления столбца используется SQL запросы:

```
ALTER TABLE таблица DROP COLUMN имя_столбца; - удаляет столбец с заданным именем
ALTER TABLE таблица DROP имя_столбца; - ключевое слово COLUMN не обязательно указывать
ALTER TABLE таблица DROP имя_столбца,
                    DROP имя_столбца_1; - удаляет два столбца
```

Для переименования столбца используется  запрос (тип данных указывать обязательно):

```
ALTER TABLE таблица CHANGE имя_столбца новое_имя_столбца ТИП ДАННЫХ;
```

Для изменения типа  столбца используется запрос (два раза указывать имя столбца обязательно): 

```
ALTER TABLE таблица CHANGE имя_столбца имя_столбца НОВЫЙ_ТИП_ДАННЫХ;
```

## Нумерация строк

Номер строки в таблице или запросе в некоторых версиях SQL можно получить с помощью оконной функции  `**row_number()**`. Когда создавался этот шаг версии SQL на платформе Stepik эта функция не поддерживалась. Сейчас версию изменили, оконные функции рассматриваются в следующем уроке.

На этом шаге нумерацию реализуем с помощью переменных. Переменные задаются с помощью ключевого слова `**SET**`, перед именем указывается символ @. Например, создадим переменную `**@row_num**` и присвоим ей значение 1:

```sql
SET @row_num := 1;
```

Теперь эту переменную можно использовать в запросах, кроме того в запросах можно изменить ее значение. 

**Пример**

Пронумеруем записи в таблице `**applicant_order**`.

*Запрос:*

```sql
SET @row_num := 0;

SELECT *, (@row_num := @row_num + 1) AS str_num
FROM  applicant_order;
```

*Результат:*

```sql
+------------+-------------+------+---------+
| program_id | enrollee_id | itog | str_num |
+------------+-------------+------+---------+
| 1          | 3           | 235  | 1       |
| 1          | 2           | 226  | 2       |
| 1          | 1           | 219  | 3       |
| 2          | 6           | 276  | 4       |
| 2          | 3           | 235  | 5       |
| 2          | 2           | 226  | 6       |
| 3          | 6           | 270  | 7       |
| 3          | 4           | 239  | 8       |
| 3          | 5           | 200  | 9       |
| 4          | 6           | 270  | 10      |
| 4          | 3           | 247  | 11      |
| 4          | 5           | 200  | 12      |
+------------+-------------+------+---------+
```

<details style="transition: var(--focus-outline-transition); box-sizing: border-box; display: block; color: rgb(34, 34, 34); font-family: Roboto, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary style="transition: var(--focus-outline-transition); box-sizing: border-box; display: list-item; cursor: pointer;"><strong style="transition: var(--focus-outline-transition); box-sizing: border-box; font-weight: 700; line-height: inherit;">Пояснение</strong></summary><p style="transition: var(--focus-outline-transition); box-sizing: border-box; margin: 1em 0px; padding: 0px; direction: ltr; line-height: inherit; font-family: inherit; font-weight: inherit; font-size: inherit; text-rendering: optimizelegibility;"><code style="transition: var(--focus-outline-transition); box-sizing: border-box; font-size: 0.9em; font-weight: inherit; color: rgb(0, 0, 0); font-family: &quot;JetBrains Mono&quot;, monospace; min-height: auto; line-height: inherit; background-color: rgb(243, 244, 246); -webkit-font-smoothing: antialiased; padding: 2px 5px; border: 1px solid rgb(236, 237, 241); border-radius: 3px;"><strong style="transition: var(--focus-outline-transition); box-sizing: border-box; font-weight: 700; line-height: inherit;"></strong></code><code style="transition: var(--focus-outline-transition); box-sizing: border-box; font-size: 0.9em; font-weight: inherit; color: rgb(0, 0, 0); font-family: &quot;JetBrains Mono&quot;, monospace; min-height: auto; line-height: inherit; background-color: rgb(243, 244, 246); -webkit-font-smoothing: antialiased; padding: 2px 5px; border: 1px solid rgb(236, 237, 241); border-radius: 3px;"><strong style="transition: var(--focus-outline-transition); box-sizing: border-box; font-weight: 700; line-height: inherit;"></strong></code></p></details>

**Пример**

Создадим нумерацию, которая начинается заново для каждой образовательной программы. Для этого можно использовать алгоритм, в котором в переменную `**@row_num**` заносится 1, если` **id**` программы в предыдущей записи не равен `**id**` программы в текущей:

- объявить переменную `**@num_pr**`, задать ей начальное значение;
- запомнить `**id**` образовательной программы для текущей записи в переменной `**@num_pr**`;
- для следующей записи сравнить значение переменной `**@num_pr**` с `**id**` образовательной программы;
- если они равны, то продолжить нумерацию `**@row_num := @row_num + 1**`;
- в противном случае начать нумерацию снова, для этого установить `**@row_num := 1**`.

*Запрос:*

```sql
SET @num_pr := 0;
SET @row_num := 1;

SELECT *, 
     if(program_id = @num_pr, @row_num := @row_num + 1, @row_num := 1) AS str_num,
     @num_pr := program_id AS add_var 
from applicant_order;
```

*Результат:*

```sql
+------------+-------------+------+---------+---------+
| program_id | enrollee_id | itog | str_num | add_var |
+------------+-------------+------+---------+---------+
| 1          | 3           | 235  | 1       | 1       |
| 1          | 2           | 226  | 2       | 1       |
| 1          | 1           | 219  | 3       | 1       |
| 2          | 6           | 276  | 1       | 2       |
| 2          | 3           | 235  | 2       | 2       |
| 2          | 2           | 226  | 3       | 2       |
| 3          | 6           | 270  | 1       | 3       |
| 3          | 4           | 239  | 2       | 3       |
| 3          | 5           | 200  | 3       | 3       |
| 4          | 6           | 270  | 1       | 4       |
| 4          | 3           | 247  | 2       | 4       |
| 4          | 5           | 200  | 3       | 4       |
+------------+-------------+------+---------+---------+
```

В `**IF**` можно делать операции над несколькими переменными, используя `**AND**`. То есть

```
IF(логическое_выражение, выражение AND выражение, выражение)
```

В столбец `**str_id**` устанавливается то, что находится перед ключевым словом `AND`, поэтому порядок важен:

> **вот_в_этот_столбец** = IF(*при этом условии*,           
>        **установи_вот_это_значение**,           
>        **иначе_установи_вот_это_значение** AND заодно_сделай_вот_это_но_в_столбец_не_устанавливай

ЗаданиеЗанести в столбец **`str_id`** таблицы `**applicant_order**` нумерацию абитуриентов, которая начинается с 1 для каждой образовательной программы.**Структура корректируемой таблицы:**![img](https://ucarecdn.com/53f4570a-9e0b-4ae7-934b-d74795b99693/)**Пояснение**``**``**``````**Пояснение от Илья Бодня**``````**Связанные шаги****Результат**``



```
set @pr_id := 0;
```

```
set @en_id := 1;
```

```

```

```
update applicant_order
```

```
set str_id = if(@pr_id = program_id, @en_id := @en_id + 1, @en_id := 1 and @pr_id := program_id);
```

```

```

```
select * from applicant_order;
```

\1. Чтобы проверить, есть ли ключевое слово в заголовке шага, можно использовать функцию:

```sql
INSTR(string_1, string_2)
```

которая возвращает позицию первого вхождения `**string_2**` в `**string_1**`. Если вхождения нет - результат функции 0.

\2. Обратите внимание, что некоторые ключевые слова, например `**IN**`, входят в `**INNER**` и `**JOIN**`. Нужно учитывать только отдельные слова, которые разделены в названии шага либо **пробелом**, либо **запятой**, либо **открывающей скобкой**.

\3. Это задание можно решить с помощью регулярных выражений ([комментарий ](https://stepik.org/lesson/404275/step/3?discussion=2970632&unit=393473) Алексея Карелина) или с помощью функции `**REGEXP_INSTR**` ([комментарий](https://stepik.org/lesson/404275/step/3?discussion=2888797&unit=393473) Yury Popov).

## Выборка данных по нескольким условиям, оператор CASE

С помощью оператора **`CASE`** можно в зависимости от нескольких условий получить один из нескольких результатов.

Оператор `**CASE**` записывается в виде:

```sql
CASE  
     WHEN логическое_выражение_1 THEN выражение_1
     WHEN логическое_выражение_2 THEN выражение_2
     ...
     ELSE выражение_else   
END  
```

Раздел **`ELSE`** является необязательным.

Выполняется оператор `**CASE**` так:

- вычисляется `**логическое_выражение_1**`, если оно истинно, то результатом оператора является `**выражение_1**`, если ложно - выполнение оператора продолжается;
- вычисляется **`логическое_выражение_2`,** если оно истинно, то результатом оператора является `**выражение_2**`, если ложно - выполнение оператора продолжается;
- если все логические выражения оказались ложными, то результат оператора - `**выражение_else**`

**`CASE`** можно использовать в  `**SELECT, UPDATE, DELETE, SET, WHERE, ORDER BY, HAVING**` - всюду, где можно использовать выражения.

**Пример**

Отнести каждого студента к группе,  в зависимости от пройденных заданий:

| **Интервал** | **Группа** |
| ------------ | ---------- |
| от 0 до 10   | I          |
| от 11 до 15  | II         |
| от 16 до 27  | III        |
| больше 27    | IV         |

Пройденными считаются задания с хотя бы одним верным ответом. В таблице `**step_student**` сохраняются все попытки пользователей, следовательно, могут быть пользователи, у которых на одно задание есть несколько верных попыток.

 ***Фрагмент логической схемы базы данных:***

![img](https://ucarecdn.com/e32cf2e7-200e-4ba9-9a7c-86244317d7fb/)

***Шаг 1.*** Выведем всех студентов и все шаги, которые они прошли с результатом "correct". Этот шаг обязателен, чтобы не учитывать правильные решения несколько раз.

*Запрос:*

```sql
SELECT student_name, step_id
FROM 
    student 
    INNER JOIN step_student USING(student_id)
WHERE result = "correct"
GROUP BY student_name, step_id;
```

Результат:

```sql
Query result:
+--------------+---------+
| student_name | step_id |
+--------------+---------+
| student_52   | 10      |
| student_11   | 10      |
| student_19   | 10      |
| student_4    | 10      |
| student_5    | 10      |
| student_53   | 10      |
| student_39   | 10      |
| student_32   | 10      |
| student_61   | 10      |
| student_43   | 10      |
| student_13   | 10      |
| student_57   | 10      |
             ...
+--------------+---------+

Affected rows: 1126.
```

 ***Шаг 2.*** Посчитаем, сколько шагов прошел каждый студент.

*Запрос:*

```sql
SELECT student_name, count(*) as rate
FROM 
    (
     SELECT student_name, step_id
     FROM 
         student 
         INNER JOIN step_student USING(student_id)
     WHERE result = "correct"
     GROUP BY student_name, step_id
    ) query_in
GROUP BY student_name
ORDER BY 2;
```

Результат:

```sql
+--------------+------+
| student_name | rate |
+--------------+------+
| student_29   | 8    |
| student_47   | 8    |
| student_16   | 9    |
| student_5    | 9    |
| student_63   | 9    |
| student_33   | 10   |
| student_17   | 10   |
| student_64   | 10   |
            ...
+--------------+------+
Affected rows: 64
```

***Шаг 3\***. Отнести каждого студента к группе в зависимости от пройденных шагов.

 *Запрос:*

```sql
SELECT student_name, rate, 
    CASE
        WHEN rate <= 10 THEN "I"
        WHEN rate <= 15 THEN "II"
        WHEN rate <= 27 THEN "III"
        ELSE "IV"
    END AS Группа
FROM      
    (
     SELECT student_name, count(*) as rate
     FROM 
         (
          SELECT student_name, step_id
          FROM 
              student 
              INNER JOIN step_student USING(student_id)
          WHERE result = "correct"
          GROUP BY student_name, step_id
         ) query_in
     GROUP BY student_name 
     ORDER BY 2
    ) query_in_1;
```

*Результат:*

```sql
Query result:
+--------------+------+--------+
| student_name | rate | Группа |
+--------------+------+--------+
| student_29   | 8    | I      |
| student_47   | 8    | I      |
| student_16   | 9    | I      |
| student_5    | 9    | I      |
| student_63   | 9    | I      |
| student_33   | 10   | I      |
| student_17   | 10   | I      |
| student_64   | 10   | I      |
| student_58   | 10   | I      |
| student_38   | 10   | I      |
| student_12   | 11   | II     |
| student_10   | 11   | II     |
              ...
+--------------+------+--------+
Affected rows: 64
```

## Табличные выражения, оператор WITH

Табличное выражение определяется с помощью оператора **`WITH`** и является частью запроса. Его синтаксис: 

```sql
WITH имя_выражения (имя_1, имя_2,...)
  AS
    (
     SELECT столбец_1, столбец_2,
     FROM 
       ... 
     )
SELECT ...
   FROM имя_выражения
   ...
```

В табличном выражении определяется запрос, результат которого нужно использовать в основной части запроса после `**SELECT**`. При этом основной запрос может обратиться к столбцам результата табличного выражения через имена, заданные в заголовке `**WITH**`. При этом количество имен должно совпадать с количеством результирующих столбцов табличного выражения.

В одном запросе может быть несколько табличных выражений. При этом в каждом табличном выражении можно использовать все предшествующие ему табличные выражения.

В табличном выражении необязательно давать имена столбцам результата. В этом случае в основном запросе можно использовать имена столбцов, указанных после `**SELECT**` в табличном выражении. При наличии одинаковых имен в нескольких табличных выражениях необходимо использовать полное имя столбца (имя табличного выражения, точка, имя столбца).

**Пример**

Для каждого шага вывести процент правильных решений. Информацию упорядочить по возрастанию процента верных решений. Столбцы результата назвать `**Шаг**` и **`Успешность`**, процент успешных решений округлить до целого.

**Важно.** Только для этого задания для одного из шагов установлено, что все ответы пользователей - неверные.

**Фрагмент логической схемы базы данных:**

![img](https://ucarecdn.com/d023dc5c-765a-4d03-ad49-6f5655790cde/)

**Шаг 1.** Создадим запрос, который для каждого шага вычисляет количество правильных ответов, данных пользователями.

*Запрос:*

```sql
SELECT step_name, count(*)
FROM 
    step 
    INNER JOIN step_student USING (step_id)
WHERE result = "correct"
GROUP BY step_name;
```

*Результат:*

```sql
+---------------------------------------------------------------+----------+
| step_name                                                     | count(*) |
+---------------------------------------------------------------+----------+
| Выборка всех данных из таблицы                                | 66       |
| Выборка отдельных столбцов                                    | 65       |
| Выборка отдельных столбцов и присвоение им новых имен         | 66       |
| Выборка данных с созданием вычисляемого столбца               | 64       |
| Выборка данных, вычисляемые столбцы, математические функции   | 66       |
                           ...
+---------------------------------------------------------------+----------+
Affected rows: 31
```

**Шаг 2.** Создадим запрос, который для каждого шага вычисляет количество неверных ответов, данных пользователями.

*Запрос:*

```sql
SELECT step_name, count(*)
FROM 
    step 
    INNER JOIN step_student USING (step_id)
WHERE result = "wrong"
GROUP BY step_name;
```

*Результат:*

```sql
+---------------------------------------------------------------+----------+
| step_name                                                     | count(*) |
+---------------------------------------------------------------+----------+
| Выборка всех данных из таблицы                                | 10       |
| Выборка отдельных столбцов                                    | 20       |
| Выборка отдельных столбцов и присвоение им новых имен         | 13       |
| Выборка данных с созданием вычисляемого столбца               | 23       |
                           ...
+---------------------------------------------------------------+----------+
Affected rows: 30
```

**Шаг 3.** Создадим запрос с табличными выражениями, который вычисляет процент верных решений. Запрос первого шага включим как табличное выражение с именем `**get_count_correct**`, запрос второго шага - как табличное выражение `**get_count_wrong**`.

*Запрос:*

```sql
WITH get_count_correct (st_n_c, count_correct) 
  AS (
      SELECT step_name, count(*)
      FROM 
          step 
          INNER JOIN step_student USING (step_id)
      WHERE result = "correct"
      GROUP BY step_name
   ),
  get_count_wrong (st_n_w, count_wrong) 
  AS (
    SELECT step_name, count(*)
    FROM 
        step 
        INNER JOIN step_student USING (step_id)
    WHERE result = "wrong"
    GROUP BY step_name
   )  
SELECT st_n_c AS Шаг, 
    ROUND(count_correct / (count_correct + count_wrong) * 100) AS Успешность
FROM  
    get_count_correct 
    INNER JOIN get_count_wrong ON st_n_c = st_n_w
```

*Результат:*

```sql
+--------------------------------------------------------------------------+------------+
| Шаг                                                                      | Успешность |
+--------------------------------------------------------------------------+------------+
| Выборка данных, оператор LIKE                                            | 19         |
| Вложенные запросы в операторах соединения                                | 32         |
| Задание. Вывести самый популярный жанр                                   | 33         |
| Запросы для нескольких таблиц с группировкой                             | 33         |
                              ...
+--------------------------------------------------------------------------+------------+
Affected rows: 30
```

**Шаг 4.** Обратите внимание, что всего вопросов в таблице 32, но запрос первого шага вывел общее количество вопросов - 31, а запрос второго шага - 30. Это значит, что на одно задание все пользователи дали неверный ответ, а на два - все пользователи дали верный ответ. 

Следовательно, нужно вместо внутреннего соединения **`INNER JOIN`** применить полное внешнее соединение `**FULL JOIN**`. Это соединение в MySQL не поддерживается, его можно реализовать запросами с **`LEFT`** и `**RIGHT JOIN**`, соединенных оператором `**UNION**`:

```sql
SELECT ...
   FROM таблица_1 LEFT JOIN таблица_2 ON ...
...
UNION
SELECT ...
   FROM таблица_1 RIGHT JOIN таблица_2 ON ...
...
```

*Запрос шага 4*:

```sql
WITH get_count_correct (st_n_c, count_correct) 
  AS (
    SELECT step_name, count(*)
    FROM 
        step 
        INNER JOIN step_student USING (step_id)
    WHERE result = "correct"
    GROUP BY step_name
   ),
  get_count_wrong (st_n_w, count_wrong) 
  AS (
    SELECT step_name, count(*)
    FROM 
        step 
        INNER JOIN step_student USING (step_id)
    WHERE result = "wrong"
    GROUP BY step_name
   )  
SELECT st_n_c AS Шаг,
    ROUND(count_correct / (count_correct + count_wrong) * 100) AS Успешность
FROM  
    get_count_correct 
    LEFT JOIN get_count_wrong ON st_n_c = st_n_w
UNION
SELECT st_n_w AS Шаг,
    ROUND(count_correct / (count_correct + count_wrong) * 100) AS Успешность
FROM  
    get_count_correct 
    RIGHT JOIN get_count_wrong ON st_n_c = st_n_w
ORDER BY 2 ;
```

*Результат:*

```sql
+--------------------------------------------------------------------------+------------+
| Шаг                                                                      | Успешность |
+--------------------------------------------------------------------------+------------+
| Задание. Работа с архивной таблицей, оператор UNION, часть 1             | None       |
| Задание. Работа с архивной таблицей, оператор UNION, часть 2             | None       |
| Построение логической схемы базы данных                                  | None       |
| Выборка данных, оператор LIKE                                            | 19         |
| Вложенные запросы в операторах соединения                                | 32         |
| Задание. Вывести самый популярный жанр                                   | 33         |
| Запросы для нескольких таблиц с группировкой                             | 33         |     
                              ...
+--------------------------------------------------------------------------+------------+
Affected rows: 32
```

Процент успешных попыток для тех шагов, которые не имеют неверных ответов или не имеют верных - `**Null**`, а должно быть 100% и 0% соответственно. Это произошло из-за того, что при внешнем соединении, вместо отсутствующего значения в результат подставляется `**Null**`.

## Оконные функции, оператор OVER, ORDER BY

Оконные функции позволяют получить некоторую дополнительную информацию о выборке данных .  С помощью оконных функций можно реализовать вычисления для набора строк, некоторым образом связанных с текущей строкой. При этом использование оконной функции не группирует несколько строк в одну, а сохраняет все строки запроса. Синтаксис оконных функций:

```sql
название_функции(выражение) 
  OVER (
        PARTITION BY столбец_1, столбец_2, ... - это окно
        ORDER BY ... - сортировка 
        ROWS BETWEEN - границы окна
          ...
  )
```

Причем все разделы `**OVER** `являются не обязательными, но обязательно нужно указать либо окно, либо сортировку. На данном шаге рассмотрим самый простой синтаксис оконного выражения:

```sql
название_функции(выражение) 
  OVER (
        ORDER BY ...
  )
```

Такое оконное выражение позволяет выполнять одинаковые действия над всеми записями таблицы (здесь окно - вся таблица). В качестве функций можно использовать:

`**ROW_NUMBER()** `- просто нумерация строк;

`**RANK()** `- ранжирование строк - при одинаковом значении строкам присваивается один номер, с пропуском номеров;

`**DENSE_RANK()**` - ранжирование строк без пропуска номеров;

`**LAG()**` - выбирает строку, предшествующую текущей, если таковой нет - выдается `**NULL**`;

`**LEAD()** `- выбирает строку, следующую за текущей, если таковой нет - выдается `**NULL**`.

**Пример**

Вычислить, сколько шагов прошел пользователь. Ранжировать пользователей по убыванию результатов.

**Фрагмент логической схемы базы данных:**

![img](https://ucarecdn.com/e32cf2e7-200e-4ba9-9a7c-86244317d7fb/)

*Запрос:*

```sql
SELECT student_name, count(DISTINCT step_id) AS Kоличество,

    ROW_NUMBER() OVER (ORDER BY  count(DISTINCT step_id) DESC) AS Номер

FROM student INNER JOIN step_student USING (student_id)
WHERE result = "correct"
GROUP BY student_name
```

*Результат:*

```sql
Query result:
+--------------+------------+-------+
| student_name | Kоличество | Номер |
+--------------+------------+-------+
| student_60   | 32         | 1     |
| student_15   | 30         | 2     |
| student_18   | 30         | 3     |
| student_27   | 30         | 4     |
| student_30   | 30         | 5     |
| student_31   | 30         | 6     |
| student_36   | 30         | 7     |
              ...
| student_5    | 9          | 61    |
| student_63   | 9          | 62    |
| student_29   | 8          | 63    |
| student_47   | 8          | 64    |
+--------------+------------+-------+
Affected rows: 64
```

В этом запросе после того, как были выбраны все студенты, посчитаны их шаги с правильными ответами, с помощью оконной функции была выполнена сортировка по количеству верных шагов (`**count(DISTINCT step_id)**`) и пронумерованы строки (функция `**ROW_NUMBER()**`).

Дополнительно ранжируем студентов.

*Запрос:*

```sql
SELECT student_name, count(DISTINCT step_id) AS Kоличество,

    ROW_NUMBER() OVER (ORDER BY  count(DISTINCT step_id) DESC) AS Номер,

    RANK() OVER (ORDER BY  count(DISTINCT step_id) DESC) AS Ранг,
    DENSE_RANK() OVER (ORDER BY  count(DISTINCT step_id) DESC) AS Рейтинг

FROM student INNER JOIN step_student USING (student_id)
WHERE result = "correct"
GROUP BY student_name
```

*Результат:*

```sql
+--------------+------------+-------+------+---------+
| student_name | Kоличество | Номер | Ранг | Рейтинг |
+--------------+------------+-------+------+---------+
| student_60   | 32         | 1     | 1    | 1       |
| student_15   | 30         | 2     | 2    | 2       |
| student_18   | 30         | 3     | 2    | 2       |
| student_27   | 30         | 4     | 2    | 2       |
| student_30   | 30         | 5     | 2    | 2       |
| student_31   | 30         | 6     | 2    | 2       |
| student_36   | 30         | 7     | 2    | 2       |
| student_39   | 30         | 8     | 2    | 2       |
| student_4    | 30         | 9     | 2    | 2       |
| student_43   | 30         | 10    | 2    | 2       |
| student_44   | 30         | 11    | 2    | 2       |
| student_46   | 30         | 12    | 2    | 2       |
| student_49   | 30         | 13    | 2    | 2       |
| student_51   | 30         | 14    | 2    | 2       |
| student_53   | 30         | 15    | 2    | 2       |
| student_59   | 29         | 16    | 16   | 3       |
| student_9    | 29         | 17    | 16   | 3       |
| student_23   | 28         | 18    | 18   | 4       |
| student_50   | 27         | 19    | 19   | 5       |
                        ...
| student_5    | 9          | 61    | 60   | 15      |
| student_63   | 9          | 62    | 60   | 15      |
| student_29   | 8          | 63    | 63   | 16      |
| student_47   | 8          | 64    | 63   | 16      |
+--------------+------------+-------+------+---------+
Affected rows: 64
```

С помощью функции `**RANK()** `и` **DENSE_RANK()**` все студенты, имеющие 30 верно пройденных шагов, получили ранг 2 и рейтинг 2. Студентам с 29 балами присвоен ранг 16 и рейтинг 3.

**Пример**

Для каждого студента указать, на сколько меньше он прошел шагов, чем идущий перед ним по рейтингу студент.

*Запрос:*

```sql
SELECT student_name, count(DISTINCT step_id) AS Количество,

       LAG(count(DISTINCT step_id)) 
       OVER (ORDER BY  count(DISTINCT step_id) DESC) - count(DISTINCT step_id) AS Разница

FROM student INNER JOIN step_student USING (student_id)
WHERE result = "correct"
GROUP BY student_name
```

*Результат:*

```sql
+--------------+------------+---------+
| student_name | Количество | Разница |
+--------------+------------+---------+
| student_60   | 32         | None    |
| student_15   | 30         | 2       |
| student_18   | 30         | 0       |
| student_27   | 30         | 0       |
| student_30   | 30         | 0       |
| student_31   | 30         | 0       |
| student_36   | 30         | 0       |

| student_63   | 9          | 0       |
| student_29   | 8          | 1       |
| student_47   | 8          | 0       |
+--------------+------------+---------+
Affected rows: 64
```

Так как у первой записи нет предыдущей - значение разницы `**NULL**`. Заменим ее на 0 с помощью функции:

```sql
IFNULL(выражение, результат)
```

которая возвращает результат, если выражение равно `**NULL**`, и само выражение в противном случае.

*Запрос:*

```
SELECT student_name, count(DISTINCT step_id) AS Количество,

       IFNULL(LAG(count(DISTINCT step_id)) 
              OVER (ORDER BY  count(DISTINCT step_id) DESC) - count(DISTINCT step_id), 
              0) AS Разница

FROM student INNER JOIN step_student USING (student_id)
WHERE result = "correct"
GROUP BY student_name
```

 *Результат:*

```sql
+--------------+------------+---------+
| student_name | Количество | Разница |
+--------------+------------+---------+
| student_60   | 32         | 0       |
| student_15   | 30         | 2       |
| student_18   | 30         | 0       |
| student_27   | 30         | 0       |
| student_30   | 30         | 0       |
| student_31   | 30         | 0       |
| student_36   | 30         | 0       |
              ...
| student_63   | 9          | 0       |
| student_29   | 8          | 1       |
| student_47   | 8          | 0       |
+--------------+------------+---------+
Affected rows: 64
```

 \1. Время в таблице `**step_student**` представлено в формате **Unix-время** , в котором хранится количество секунд, прошедших с 1 января 1970 года. Для перевода к привычному виду `**DATE**` используется формула:

```sql
1970-01-01 + time_unix / 86400
```

В SQL для перевода удобно использовать функцию **`FROM_UNIXTIME( ).`**

Например:

```sql
FROM_UNIXTIME(1598291490) =  2020-08-24 17:51:30
```

\2. Для перевода количества секунд во временной формат используется функция `**SEC_TO_TIME(),**`например:

```
**SEC_TO_TIME(288) = 0:04:48**
```

## Оконные функции, оператор OVER, PARTITION BY

Рассмотрим оконную функцию, которая включает два раздела:

```sql
название_функции(выражение) 
  OVER (
        PARTITION BY ...
        ORDER BY ... 
  )
```

Такое оконное выражение позволяет выполнять одинаковые действия над всеми записями таблицы, ограниченными "окном". Столбцы, образующие окно записываются после  PARTITION BY. Окном считается совокупность записей, имеющих в столбцах, указанных после PARTITION BY, одинаковые значения.

В качестве функций можно использовать те же функции, которые применялись в оконных функциях без указания окна:

`**ROW_NUMBER()** `- просто нумерация строк внутри окна;

`**RANK()** `- ранжирование строк внутри окна - при одинаковом значении строкам присваивается один номер, с пропуском номеров;

`**DENSE_RANK()**` - ранжирование строк внутри окна без пропуска номеров;

`**LAG()**` - выбирает строку внутри окна, предшествующую текущей, если таковой нет - выдается NULL;

`**LEAD()** `- выбирает строку внутри окна, следующую за текущей, если таковой нет - выдается NULL.

**Пример**

Вычислить, [сколько шагов прошел пользователь ](https://stepik.org/lesson/404275/step/8?unit=393473)по каждому модулю. Ранжировать пользователей по убыванию результатов в каждом модуле.

**Фрагмент логической схемы базы данных:**

![img](https://ucarecdn.com/c6a428d7-dbe1-4339-baac-273cb5616865/)

*Запрос:*

```sql
WITH get_rate_lesson(mod_id, stud, rate) 
AS
(
   SELECT module_id, student_name, count(DISTINCT step_id)
   FROM student INNER JOIN step_student USING(student_id)
                INNER JOIN step USING (step_id)
                INNER JOIN lesson USING (lesson_id)
   WHERE result = "correct"
   GROUP BY module_id, student_name
)
SELECT mod_id AS Модуль, stud AS Студент, rate AS Рейтинг,
    ROW_NUMBER() OVER (PARTITION BY mod_id ORDER BY  rate DESC) AS Номер,
    RANK() OVER (PARTITION BY mod_id ORDER BY  rate DESC) AS Ранг,
    DENSE_RANK() OVER (PARTITION BY mod_id ORDER BY  rate DESC) AS Рейтинг  
FROM get_rate_lesson 
```

*Результат:*

```sql
+--------+------------+---------+-------+------+---------+
| Модуль | Студент    | Рейтинг | Номер | Ранг | Рейтинг |
+--------+------------+---------+-------+------+---------+
| 1      | student_1  | 11      | 1     | 1    | 1       |
| 1      | student_10 | 11      | 2     | 1    | 1       |
| 1      | student_11 | 11      | 3     | 1    | 1       |
| 1      | student_12 | 11      | 4     | 1    | 1       |
| 1      | student_13 | 11      | 5     | 1    | 1       |
                        ...
| 1      | student_29 | 8       | 63    | 63   | 4       |
| 1      | student_47 | 8       | 64    | 63   | 4       |
| 2      | student_60 | 21      | 1     | 1    | 1       |
| 2      | student_15 | 19      | 2     | 2    | 2       |
                        ...
| 2      | student_56 | 9       | 23    | 22   | 7       |
| 2      | student_34 | 8       | 24    | 24   | 8       |
| 2      | student_40 | 8       | 25    | 24   | 8       |
| 2      | student_11 | 5       | 26    | 26   | 9       |
| 2      | student_48 | 5       | 27    | 26   | 9       |
| 2      | student_42 | 4       | 28    | 28   | 10      |
| 2      | student_61 | 3       | 29    | 29   | 11      |
| 2      | student_13 | 2       | 30    | 30   | 12      |
| 2      | student_26 | 2       | 31    | 30   | 12      |
+--------+------------+---------+-------+------+---------+
Affected rows: 95
```

Как видно из результирующей таблицы, и нумерация, и ранжирование, и рейтинг осуществляется сначала (с 1) для каждого модуля.

Другой тип функций - это функции, которые используются для вычислений со значениями столбцов, входящих в окно:

```sql
SUM(), MAX(), MIN(), AVG(), COUNT()
```

По записи они точно соответствуют групповым функциям, при этом вычисленное значение заносится в каждую запись окна. В то время как при использовании группировки возвращается одна запись для каждой группы.

Как правило, эти функции используются в следующем контексте:

```sql
название_функции(выражение) 
  OVER (
        PARTITION BY ...
  )
```

**Пример**

Посчитать, сколько шагов пройдено пользователями по каждому уроку. Вывести максимальное и минимальное значение пройденных шагов по каждому модулю.

*Запрос:*

```sql
WITH get_rate_lesson(mod_id, les, rate) 
AS
(
   SELECT module_id,CONCAT(module_id,'.', lesson_position),count(DISTINCT step_id)
   FROM step_student INNER JOIN step USING (step_id)
                     INNER JOIN lesson USING (lesson_id)
   WHERE result = "correct"
   GROUP BY module_id, 2
)
SELECT mod_id AS Модуль, les AS Урок, rate AS Пройдено_шагов, 
    MAX(rate) OVER (PARTITION BY mod_id) AS Максимум_по_модулю,
    MIN(rate) OVER (PARTITION BY mod_id) AS Минимум_по_модулю
FROM get_rate_lesson 
```

*Результат:*

```sql
+--------+------+----------------+--------------------+-------------------+
| Модуль | Урок | Пройдено_шагов | Максимум_по_модулю | Минимум_по_модулю |
+--------+------+----------------+--------------------+-------------------+
| 1      | 1.2  | 11             | 11                 | 11                |
| 2      | 2.2  | 8              | 13                 | 8                 |
| 2      | 2.4  | 13             | 13                 | 8                 |
+--------+------+----------------+--------------------+-------------------+
Affected rows: 3
```

```
set @avg_time := (
    select 
        avg(submission_time - attempt_time)
    from 
        student
        join step_student using(student_id)
        join step using(step_id)
        join lesson using(lesson_id)
        join module using(module_id)
    where
        student_name = 'student_59' and submission_time - attempt_time < 3600
    group by 
        student_id
    );

with student_step (student_id, step_str, attempt_num, result, attempt_time, rel_time, step_id)
as (
    select 
        student.student_id,
        concat(module_id, '.', lesson_position, '.', step_position),
        row_number() over (partition by student_id, step.step_id order by submission_time),
        result,
        sec_to_time(round(if(submission_time - attempt_time < 3600, submission_time - attempt_time, @avg_time))),
        round(if(submission_time - attempt_time < 3600, submission_time - attempt_time, @avg_time) / sum_time * 100, 2),
        step.step_id
        
    from 
        student
        join step_student using(student_id)
        join step using(step_id)
        join lesson using(lesson_id)
        join module using(module_id)
        inner join (
            select
                student.student_id, step.step_id, sum(round(if(submission_time - attempt_time < 3600, submission_time - attempt_time, @avg_time))) as sum_time
            from
                student
                join step_student using(student_id)
                join step using(step_id)
                join lesson using(lesson_id)
                join module using(module_id)
            group by
                student.student_id, step.step_id) as q on q.student_id = student.student_id and q.step_id = step.step_id
    where
        student_name = 'student_59'
    group by
        student_id,
        step_student_id
    )
select
    student_name as Студент,
    step_str as Шаг,
    attempt_num as Номер_попытки,
    result as Результат,
    attempt_time as Время_попытки,
    rel_time as Относительное_время
from 
    student_step
    inner join student using(student_id)
order by
    step_id, 3;





```

